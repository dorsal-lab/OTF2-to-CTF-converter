/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015-2020 Philippe Proulx <pproulx@efficios.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * The following code was generated by barectf v3.0.1
 * on 2021-10-29T15:39:33.565575.
 *
 * For more details, see <https://barectf.org/>.
 */

#include <stdint.h>
#include <string.h>
#include <assert.h>

#include "barectf.h"
#include "barectf-bitfield.h"

#define _ALIGN(_at_var, _align)						\
	do {								\
		(_at_var) = ((_at_var) + ((_align) - 1)) & -(_align);	\
	} while (0)

#ifdef __cplusplus
# define _TO_VOID_PTR(_value)		static_cast<void *>(_value)
# define _FROM_VOID_PTR(_type, _value)	static_cast<_type *>(_value)
#else
# define _TO_VOID_PTR(_value)		((void *) (_value))
# define _FROM_VOID_PTR(_type, _value)	((_type *) (_value))
#endif

#define _BITS_TO_BYTES(_x)	((_x) >> 3)
#define _BYTES_TO_BITS(_x)	((_x) << 3)

union _f2u {
	float f;
	uint32_t u;
};

union _d2u {
	double f;
	uint64_t u;
};

uint32_t barectf_packet_size(const void * const vctx)
{
	return _FROM_VOID_PTR(const struct barectf_ctx, vctx)->packet_size;
}

int barectf_packet_is_full(const void * const vctx)
{
	const struct barectf_ctx * const ctx = _FROM_VOID_PTR(const struct barectf_ctx, vctx);

	return ctx->at == ctx->packet_size;
}

int barectf_packet_is_empty(const void * const vctx)
{
	const struct barectf_ctx * const ctx = _FROM_VOID_PTR(const struct barectf_ctx, vctx);

	return ctx->at <= ctx->off_content;
}

uint32_t barectf_packet_events_discarded(const void * const vctx)
{
	return _FROM_VOID_PTR(const struct barectf_ctx, vctx)->events_discarded;
}

uint32_t barectf_discarded_event_records_count(const void * const vctx)
{
	return barectf_packet_events_discarded(vctx);
}

uint8_t *barectf_packet_buf(const void * const vctx)
{
	return _FROM_VOID_PTR(const struct barectf_ctx, vctx)->buf;
}

uint8_t *barectf_packet_buf_addr(const void * const vctx)
{
	return barectf_packet_buf(vctx);
}

uint32_t barectf_packet_buf_size(const void * const vctx)
{
	const struct barectf_ctx * const ctx = _FROM_VOID_PTR(const struct barectf_ctx, vctx);

	return _BITS_TO_BYTES(ctx->packet_size);
}

void barectf_packet_set_buf(void * const vctx, uint8_t * const buf,
		const uint32_t buf_size)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	ctx->buf = buf;

	if (ctx->at == ctx->packet_size) {
		/* Keep full packet state */
		ctx->at = _BYTES_TO_BITS(buf_size);
	}

	ctx->packet_size = _BYTES_TO_BITS(buf_size);
}

int barectf_packet_is_open(const void * const vctx)
{
	return _FROM_VOID_PTR(const struct barectf_ctx, vctx)->packet_is_open;
}

int barectf_is_in_tracing_section(const void * const vctx)
{
	return _FROM_VOID_PTR(const struct barectf_ctx, vctx)->in_tracing_section;
}

volatile const int *barectf_is_in_tracing_section_ptr(const void * const vctx)
{
	return &_FROM_VOID_PTR(const struct barectf_ctx, vctx)->in_tracing_section;
}

int barectf_is_tracing_enabled(const void * const vctx)
{
	return _FROM_VOID_PTR(const struct barectf_ctx, vctx)->is_tracing_enabled;
}

void barectf_enable_tracing(void * const vctx, const int enable)
{
	_FROM_VOID_PTR(struct barectf_ctx, vctx)->is_tracing_enabled = enable;
}

static
void _write_c_str(struct barectf_ctx * const ctx, const char * const src)
{
	const uint32_t sz = strlen(src) + 1;

	memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], src, sz);
	ctx->at += _BYTES_TO_BITS(sz);
}

static
int _reserve_er_space(void * const vctx, const uint32_t er_size)
{
	int ret;
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Event _cannot_ fit? */
	if (er_size > (ctx->packet_size - ctx->off_content)) {
		goto no_space;
	}

	/* Packet is full? */
	if (barectf_packet_is_full(ctx)) {
		/* Yes: is the back end full? */
		if (ctx->cbs.is_backend_full(ctx->data)) {
			/* Yes: discard event record */
			goto no_space;
		}

		/* Back-end is _not_ full: open new packet */
		ctx->use_cur_last_event_ts = 1;
		ctx->cbs.open_packet(ctx->data);
		ctx->use_cur_last_event_ts = 0;
	}

	/* Event fits the current packet? */
	if (er_size > (ctx->packet_size - ctx->at)) {
		/* No: close packet now */
		ctx->use_cur_last_event_ts = 1;
		ctx->cbs.close_packet(ctx->data);
		ctx->use_cur_last_event_ts = 0;

		/* Is the back end full? */
		if (ctx->cbs.is_backend_full(ctx->data)) {
			/* Yes: discard event record */
			goto no_space;
		}

		/* Back-end is _not_ full: open new packet */
		ctx->use_cur_last_event_ts = 1;
		ctx->cbs.open_packet(ctx->data);
		ctx->use_cur_last_event_ts = 0;
		assert(er_size <= (ctx->packet_size - ctx->at));
	}

	ret = 1;
	goto end;

no_space:
	ctx->events_discarded++;
	ret = 0;

end:
	return ret;
}

static
void _commit_er(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Is the packet full? */
	if (barectf_packet_is_full(ctx)) {
		/* Yes: close it now */
		ctx->cbs.close_packet(ctx->data);
	}
}

/* Initialize context */
void barectf_init(void *vctx,
	uint8_t * const buf, const uint32_t buf_size,
	const struct barectf_platform_callbacks cbs, void * const data)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	ctx->cbs = cbs;
	ctx->data = data;
	ctx->buf = buf;
	ctx->packet_size = _BYTES_TO_BITS(buf_size);
	ctx->at = 0;
	ctx->events_discarded = 0;
	ctx->packet_is_open = 0;
	ctx->in_tracing_section = 0;
	ctx->is_tracing_enabled = 1;
	ctx->use_cur_last_event_ts = 0;
}

/* Open packet for data stream type `default` */
void barectf_default_open_packet(
	struct barectf_default_ctx * const sctx)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	const uint64_t ts = ctx->use_cur_last_event_ts ?
		sctx->cur_last_event_ts :
		ctx->cbs.default_clock_get_value(ctx->data);
	const int saved_in_tracing_section = ctx->in_tracing_section;

	/*
	 * This function is either called by a tracing function, or
	 * directly by the platform.
	 *
	 * If it's called by a tracing function, then
	 * `ctx->in_tracing_section` is 1, so it's safe to open
	 * the packet here (alter the packet), even if tracing was
	 * disabled in the meantime because we're already in a tracing
	 * section (which finishes at the end of the tracing function
	 * call).
	 *
	 * If it's called directly by the platform, then if tracing is
	 * disabled, we don't want to alter the packet, and return
	 * immediately.
	 */
	if (!ctx->is_tracing_enabled && !saved_in_tracing_section) {
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Do not open a packet that is already open */
	if (ctx->packet_is_open) {
		ctx->in_tracing_section = saved_in_tracing_section;
		goto end;
	}

	ctx->at = 0;

	/* Write packet header structure */
	{
		/* Align for packet header structure */
		_ALIGN(ctx->at, 8);

		/* Align for `magic` field */
		_ALIGN(ctx->at, 8);

		/* Write magic number field */
		{
			const uint32_t tmp_val = (uint32_t) 0xc1fc1fc1UL;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `stream_id` field */
		_ALIGN(ctx->at, 8);

		/* Write data stream type ID field */
		{
			const uint64_t tmp_val = (uint64_t) 0;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}

	/* Write packet context structure */
	{
		/* Align for packet context structure */
		_ALIGN(ctx->at, 8);

		/* Align for `packet_size` field */
		_ALIGN(ctx->at, 8);

		/* Write packet total size field */
		{
			const uint64_t tmp_val = (uint64_t) ctx->packet_size;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `content_size` field */
		_ALIGN(ctx->at, 8);

		/* Do not write `content_size` field; save its offset */
		sctx->off_pc_content_size = ctx->at;
		ctx->at += 64;

		/* Align for `timestamp_begin` field */
		_ALIGN(ctx->at, 8);

		/* Write beginning timestamp field */
		{
			const uint64_t tmp_val = (uint64_t) ts;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `timestamp_end` field */
		_ALIGN(ctx->at, 8);

		/* Do not write `timestamp_end` field; save its offset */
		sctx->off_pc_timestamp_end = ctx->at;
		ctx->at += 64;

		/* Align for `events_discarded` field */
		_ALIGN(ctx->at, 8);

		/* Do not write `events_discarded` field; save its offset */
		sctx->off_pc_events_discarded = ctx->at;
		ctx->at += 64;
	}

	/* Save content beginning's offset */
	ctx->off_content = ctx->at;

	/* Mark current packet as open */
	ctx->packet_is_open = 1;

	/* Not tracing anymore */
	ctx->in_tracing_section = saved_in_tracing_section;

end:
	return;
}

/* Close packet for data stream type `default` */
void barectf_default_close_packet(struct barectf_default_ctx * const sctx)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	const uint64_t ts = ctx->use_cur_last_event_ts ?
		sctx->cur_last_event_ts :
		ctx->cbs.default_clock_get_value(ctx->data);
	const int saved_in_tracing_section = ctx->in_tracing_section;

	/*
	 * This function is either called by a tracing function, or
	 * directly by the platform.
	 *
	 * If it's called by a tracing function, then
	 * `ctx->in_tracing_section` is 1, so it's safe to close
	 * the packet here (alter the packet), even if tracing was
	 * disabled in the meantime, because we're already in a tracing
	 * section (which finishes at the end of the tracing function
	 * call).
	 *
	 * If it's called directly by the platform, then if tracing is
	 * disabled, we don't want to alter the packet, and return
	 * immediately.
	 */
	if (!ctx->is_tracing_enabled && !saved_in_tracing_section) {
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Do not close a packet that is not open */
	if (!ctx->packet_is_open) {
		ctx->in_tracing_section = saved_in_tracing_section;
		goto end;
	}

	/* Save content size */
	ctx->content_size = ctx->at;

	/* Go back to `timestamp_end` field offset */
	ctx->at = sctx->off_pc_timestamp_end;

	/* Write `timestamp_end` field */
	{
		const uint64_t tmp_val = (uint64_t) ts;

		memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
		ctx->at += 64;
	}

	/* Go back to `content_size` field offset */
	ctx->at = sctx->off_pc_content_size;

	/* Write `content_size` field */
	{
		const uint64_t tmp_val = (uint64_t) ctx->content_size;

		memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
		ctx->at += 64;
	}

	/* Go back to `events_discarded` field offset */
	ctx->at = sctx->off_pc_events_discarded;

	/* Write `events_discarded` field */
	{
		const uint64_t tmp_val = (uint64_t) ctx->events_discarded;

		memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
		ctx->at += 64;
	}

	/* Go back to end of packet */
	ctx->at = ctx->packet_size;

	/* Mark packet as closed */
	ctx->packet_is_open = 0;

	/* Not tracing anymore */
	ctx->in_tracing_section = saved_in_tracing_section;

end:
	return;
}

static void _serialize_er_header_default(void * const vctx,
	const uint32_t ert_id)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	struct barectf_default_ctx * const sctx = _FROM_VOID_PTR(struct barectf_default_ctx, vctx);
	const uint64_t ts = sctx->cur_last_event_ts;

	/* Write header structure */
	{
		/* Align for header structure */
		_ALIGN(ctx->at, 8);

		/* Align for `id` field */
		_ALIGN(ctx->at, 8);

		/* Write event record type ID field */
		{
			const uint64_t tmp_val = (uint64_t) ert_id;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `timestamp` field */
		_ALIGN(ctx->at, 8);

		/* Write timestamp field */
		{
			const uint64_t tmp_val = (uint64_t) ts;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_EventAttribute_Attribute(void * const vctx,
	const uint32_t p_attribute,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 0);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `attribute` field */
		_ALIGN(ctx->at, 32);

		/* Write `attribute` field */
		{
			const uint32_t tmp_val = (uint32_t) p_attribute;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `value` field */
		_ALIGN(ctx->at, 32);

		/* Write `value` field */
		{
			const uint32_t tmp_val = (uint32_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_EventAttribute_CallingContext(void * const vctx,
	const uint32_t p_attribute,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 1);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `attribute` field */
		_ALIGN(ctx->at, 32);

		/* Write `attribute` field */
		{
			const uint32_t tmp_val = (uint32_t) p_attribute;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `value` field */
		_ALIGN(ctx->at, 32);

		/* Write `value` field */
		{
			const uint32_t tmp_val = (uint32_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_EventAttribute_Comm(void * const vctx,
	const uint32_t p_attribute,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 2);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `attribute` field */
		_ALIGN(ctx->at, 32);

		/* Write `attribute` field */
		{
			const uint32_t tmp_val = (uint32_t) p_attribute;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `value` field */
		_ALIGN(ctx->at, 32);

		/* Write `value` field */
		{
			const uint32_t tmp_val = (uint32_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_EventAttribute_Double(void * const vctx,
	const uint32_t p_attribute,
	const double p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 3);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `attribute` field */
		_ALIGN(ctx->at, 32);

		/* Write `attribute` field */
		{
			const uint32_t tmp_val = (uint32_t) p_attribute;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `value` field */
		_ALIGN(ctx->at, 64);

		/* Write `value` field */
		{
			union _d2u d2u;

			d2u.f = p_value;
			{
				const uint64_t tmp_val = (uint64_t) d2u.u;

				memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
				ctx->at += 64;
			}
		}
	}
}

static void _serialize_er_default_EventAttribute_Float(void * const vctx,
	const uint32_t p_attribute,
	const float p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 4);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `attribute` field */
		_ALIGN(ctx->at, 32);

		/* Write `attribute` field */
		{
			const uint32_t tmp_val = (uint32_t) p_attribute;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `value` field */
		_ALIGN(ctx->at, 32);

		/* Write `value` field */
		{
			union _f2u f2u;

			f2u.f = p_value;
			{
				const uint32_t tmp_val = (uint32_t) f2u.u;

				memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
				ctx->at += 32;
			}
		}
	}
}

static void _serialize_er_default_EventAttribute_Group(void * const vctx,
	const uint32_t p_attribute,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 5);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `attribute` field */
		_ALIGN(ctx->at, 32);

		/* Write `attribute` field */
		{
			const uint32_t tmp_val = (uint32_t) p_attribute;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `value` field */
		_ALIGN(ctx->at, 32);

		/* Write `value` field */
		{
			const uint32_t tmp_val = (uint32_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_EventAttribute_Int16(void * const vctx,
	const uint32_t p_attribute,
	const int16_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 6);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `attribute` field */
		_ALIGN(ctx->at, 32);

		/* Write `attribute` field */
		{
			const uint32_t tmp_val = (uint32_t) p_attribute;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `value` field */
		_ALIGN(ctx->at, 16);

		/* Write `value` field */
		{
			const uint16_t tmp_val = (uint16_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 16;
		}
	}
}

static void _serialize_er_default_EventAttribute_Int32(void * const vctx,
	const uint32_t p_attribute,
	const int32_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 7);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `attribute` field */
		_ALIGN(ctx->at, 32);

		/* Write `attribute` field */
		{
			const uint32_t tmp_val = (uint32_t) p_attribute;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `value` field */
		_ALIGN(ctx->at, 32);

		/* Write `value` field */
		{
			const uint32_t tmp_val = (uint32_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_EventAttribute_Int64(void * const vctx,
	const uint32_t p_attribute,
	const int64_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 8);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `attribute` field */
		_ALIGN(ctx->at, 32);

		/* Write `attribute` field */
		{
			const uint32_t tmp_val = (uint32_t) p_attribute;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `value` field */
		_ALIGN(ctx->at, 64);

		/* Write `value` field */
		{
			const uint64_t tmp_val = (uint64_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_EventAttribute_Int8(void * const vctx,
	const uint32_t p_attribute,
	const int8_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 9);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `attribute` field */
		_ALIGN(ctx->at, 32);

		/* Write `attribute` field */
		{
			const uint32_t tmp_val = (uint32_t) p_attribute;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `value` field */
		_ALIGN(ctx->at, 8);

		/* Write `value` field */
		{
			const uint8_t tmp_val = (uint8_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}
	}
}

static void _serialize_er_default_EventAttribute_InterruptGenerator(void * const vctx,
	const uint32_t p_attribute,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 10);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `attribute` field */
		_ALIGN(ctx->at, 32);

		/* Write `attribute` field */
		{
			const uint32_t tmp_val = (uint32_t) p_attribute;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `value` field */
		_ALIGN(ctx->at, 32);

		/* Write `value` field */
		{
			const uint32_t tmp_val = (uint32_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_EventAttribute_IoFile(void * const vctx,
	const uint32_t p_attribute,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 11);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `attribute` field */
		_ALIGN(ctx->at, 32);

		/* Write `attribute` field */
		{
			const uint32_t tmp_val = (uint32_t) p_attribute;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `value` field */
		_ALIGN(ctx->at, 32);

		/* Write `value` field */
		{
			const uint32_t tmp_val = (uint32_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_EventAttribute_IoHandle(void * const vctx,
	const uint32_t p_attribute,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 12);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `attribute` field */
		_ALIGN(ctx->at, 32);

		/* Write `attribute` field */
		{
			const uint32_t tmp_val = (uint32_t) p_attribute;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `value` field */
		_ALIGN(ctx->at, 32);

		/* Write `value` field */
		{
			const uint32_t tmp_val = (uint32_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_EventAttribute_Location(void * const vctx,
	const uint32_t p_attribute,
	const uint64_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 13);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `attribute` field */
		_ALIGN(ctx->at, 32);

		/* Write `attribute` field */
		{
			const uint32_t tmp_val = (uint32_t) p_attribute;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `value` field */
		_ALIGN(ctx->at, 64);

		/* Write `value` field */
		{
			const uint64_t tmp_val = (uint64_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_EventAttribute_Metric(void * const vctx,
	const uint32_t p_attribute,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 14);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `attribute` field */
		_ALIGN(ctx->at, 32);

		/* Write `attribute` field */
		{
			const uint32_t tmp_val = (uint32_t) p_attribute;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `value` field */
		_ALIGN(ctx->at, 32);

		/* Write `value` field */
		{
			const uint32_t tmp_val = (uint32_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_EventAttribute_Parameter(void * const vctx,
	const uint32_t p_attribute,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 15);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `attribute` field */
		_ALIGN(ctx->at, 32);

		/* Write `attribute` field */
		{
			const uint32_t tmp_val = (uint32_t) p_attribute;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `value` field */
		_ALIGN(ctx->at, 32);

		/* Write `value` field */
		{
			const uint32_t tmp_val = (uint32_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_EventAttribute_Region(void * const vctx,
	const uint32_t p_attribute,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 16);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `attribute` field */
		_ALIGN(ctx->at, 32);

		/* Write `attribute` field */
		{
			const uint32_t tmp_val = (uint32_t) p_attribute;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `value` field */
		_ALIGN(ctx->at, 32);

		/* Write `value` field */
		{
			const uint32_t tmp_val = (uint32_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_EventAttribute_RmaWin(void * const vctx,
	const uint32_t p_attribute,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 17);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `attribute` field */
		_ALIGN(ctx->at, 32);

		/* Write `attribute` field */
		{
			const uint32_t tmp_val = (uint32_t) p_attribute;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `value` field */
		_ALIGN(ctx->at, 32);

		/* Write `value` field */
		{
			const uint32_t tmp_val = (uint32_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_EventAttribute_SourceCodeLocation(void * const vctx,
	const uint32_t p_attribute,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 18);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `attribute` field */
		_ALIGN(ctx->at, 32);

		/* Write `attribute` field */
		{
			const uint32_t tmp_val = (uint32_t) p_attribute;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `value` field */
		_ALIGN(ctx->at, 32);

		/* Write `value` field */
		{
			const uint32_t tmp_val = (uint32_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_EventAttribute_String(void * const vctx,
	const uint32_t p_attribute,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 19);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `attribute` field */
		_ALIGN(ctx->at, 32);

		/* Write `attribute` field */
		{
			const uint32_t tmp_val = (uint32_t) p_attribute;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `value` field */
		_ALIGN(ctx->at, 32);

		/* Write `value` field */
		{
			const uint32_t tmp_val = (uint32_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_EventAttribute_UInt16(void * const vctx,
	const uint32_t p_attribute,
	const uint16_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 20);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `attribute` field */
		_ALIGN(ctx->at, 32);

		/* Write `attribute` field */
		{
			const uint32_t tmp_val = (uint32_t) p_attribute;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `value` field */
		_ALIGN(ctx->at, 16);

		/* Write `value` field */
		{
			const uint16_t tmp_val = (uint16_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 16;
		}
	}
}

static void _serialize_er_default_EventAttribute_UInt32(void * const vctx,
	const uint32_t p_attribute,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 21);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `attribute` field */
		_ALIGN(ctx->at, 32);

		/* Write `attribute` field */
		{
			const uint32_t tmp_val = (uint32_t) p_attribute;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `value` field */
		_ALIGN(ctx->at, 32);

		/* Write `value` field */
		{
			const uint32_t tmp_val = (uint32_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_EventAttribute_UInt64(void * const vctx,
	const uint32_t p_attribute,
	const uint64_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 22);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `attribute` field */
		_ALIGN(ctx->at, 32);

		/* Write `attribute` field */
		{
			const uint32_t tmp_val = (uint32_t) p_attribute;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `value` field */
		_ALIGN(ctx->at, 64);

		/* Write `value` field */
		{
			const uint64_t tmp_val = (uint64_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_EventAttribute_UInt8(void * const vctx,
	const uint32_t p_attribute,
	const uint8_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 23);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `attribute` field */
		_ALIGN(ctx->at, 32);

		/* Write `attribute` field */
		{
			const uint32_t tmp_val = (uint32_t) p_attribute;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `value` field */
		_ALIGN(ctx->at, 8);

		/* Write `value` field */
		{
			const uint8_t tmp_val = (uint8_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}
	}
}

static void _serialize_er_default_Event_BufferFlush(void * const vctx,
	const uint64_t p_locationID,
	const uint64_t p_stopTime)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 24);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `stopTime` field */
		_ALIGN(ctx->at, 64);

		/* Write `stopTime` field */
		{
			const uint64_t tmp_val = (uint64_t) p_stopTime;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_Event_CallingContextEnter(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_callingContext,
	const uint32_t p_unwindDistance)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 25);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `callingContext` field */
		_ALIGN(ctx->at, 32);

		/* Write `callingContext` field */
		{
			const uint32_t tmp_val = (uint32_t) p_callingContext;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `unwindDistance` field */
		_ALIGN(ctx->at, 32);

		/* Write `unwindDistance` field */
		{
			const uint32_t tmp_val = (uint32_t) p_unwindDistance;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_Event_CallingContextLeave(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_callingContext)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 26);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `callingContext` field */
		_ALIGN(ctx->at, 32);

		/* Write `callingContext` field */
		{
			const uint32_t tmp_val = (uint32_t) p_callingContext;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_Event_CallingContextSample(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_callingContext,
	const uint32_t p_unwindDistance,
	const uint32_t p_interruptGenerator)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 27);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `callingContext` field */
		_ALIGN(ctx->at, 32);

		/* Write `callingContext` field */
		{
			const uint32_t tmp_val = (uint32_t) p_callingContext;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `unwindDistance` field */
		_ALIGN(ctx->at, 32);

		/* Write `unwindDistance` field */
		{
			const uint32_t tmp_val = (uint32_t) p_unwindDistance;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `interruptGenerator` field */
		_ALIGN(ctx->at, 32);

		/* Write `interruptGenerator` field */
		{
			const uint32_t tmp_val = (uint32_t) p_interruptGenerator;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_Event_Enter(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_region)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 28);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `region` field */
		_ALIGN(ctx->at, 32);

		/* Write `region` field */
		{
			const uint32_t tmp_val = (uint32_t) p_region;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_Event_IoAcquireLock(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_handle,
	const uint8_t p_lockType)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 29);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `handle` field */
		_ALIGN(ctx->at, 32);

		/* Write `handle` field */
		{
			const uint32_t tmp_val = (uint32_t) p_handle;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `lockType` field */
		_ALIGN(ctx->at, 8);

		/* Write `lockType` field */
		{
			const uint8_t tmp_val = (uint8_t) p_lockType;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}
	}
}

static void _serialize_er_default_Event_IoChangeStatusFlags(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_handle,
	const uint32_t p_statusFlags)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 30);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `handle` field */
		_ALIGN(ctx->at, 32);

		/* Write `handle` field */
		{
			const uint32_t tmp_val = (uint32_t) p_handle;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `statusFlags` field */
		_ALIGN(ctx->at, 32);

		/* Write `statusFlags` field */
		{
			const uint32_t tmp_val = (uint32_t) p_statusFlags;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_Event_IoCreateHandle(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_handle,
	const uint8_t p_mode,
	const uint32_t p_creationFlags,
	const uint32_t p_statusFlags)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 31);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `handle` field */
		_ALIGN(ctx->at, 32);

		/* Write `handle` field */
		{
			const uint32_t tmp_val = (uint32_t) p_handle;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `mode` field */
		_ALIGN(ctx->at, 8);

		/* Write `mode` field */
		{
			const uint8_t tmp_val = (uint8_t) p_mode;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}

		/* Align for `creationFlags` field */
		_ALIGN(ctx->at, 32);

		/* Write `creationFlags` field */
		{
			const uint32_t tmp_val = (uint32_t) p_creationFlags;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `statusFlags` field */
		_ALIGN(ctx->at, 32);

		/* Write `statusFlags` field */
		{
			const uint32_t tmp_val = (uint32_t) p_statusFlags;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_Event_IoDeleteFile(void * const vctx,
	const uint64_t p_locationID,
	const uint8_t p_ioParadigm,
	const uint32_t p_file)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 32);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `ioParadigm` field */
		_ALIGN(ctx->at, 8);

		/* Write `ioParadigm` field */
		{
			const uint8_t tmp_val = (uint8_t) p_ioParadigm;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}

		/* Align for `file` field */
		_ALIGN(ctx->at, 32);

		/* Write `file` field */
		{
			const uint32_t tmp_val = (uint32_t) p_file;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_Event_IoDestroyHandle(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_handle)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 33);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `handle` field */
		_ALIGN(ctx->at, 32);

		/* Write `handle` field */
		{
			const uint32_t tmp_val = (uint32_t) p_handle;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_Event_IoDuplicateHandle(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_oldHandle,
	const uint32_t p_newHandle,
	const uint32_t p_statusFlags)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 34);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `oldHandle` field */
		_ALIGN(ctx->at, 32);

		/* Write `oldHandle` field */
		{
			const uint32_t tmp_val = (uint32_t) p_oldHandle;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `newHandle` field */
		_ALIGN(ctx->at, 32);

		/* Write `newHandle` field */
		{
			const uint32_t tmp_val = (uint32_t) p_newHandle;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `statusFlags` field */
		_ALIGN(ctx->at, 32);

		/* Write `statusFlags` field */
		{
			const uint32_t tmp_val = (uint32_t) p_statusFlags;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_Event_IoOperationBegin(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_handle,
	const uint8_t p_mode,
	const uint32_t p_operationFlags,
	const uint64_t p_bytesRequest,
	const uint64_t p_matchingId)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 35);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `handle` field */
		_ALIGN(ctx->at, 32);

		/* Write `handle` field */
		{
			const uint32_t tmp_val = (uint32_t) p_handle;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `mode` field */
		_ALIGN(ctx->at, 8);

		/* Write `mode` field */
		{
			const uint8_t tmp_val = (uint8_t) p_mode;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}

		/* Align for `operationFlags` field */
		_ALIGN(ctx->at, 32);

		/* Write `operationFlags` field */
		{
			const uint32_t tmp_val = (uint32_t) p_operationFlags;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `bytesRequest` field */
		_ALIGN(ctx->at, 64);

		/* Write `bytesRequest` field */
		{
			const uint64_t tmp_val = (uint64_t) p_bytesRequest;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `matchingId` field */
		_ALIGN(ctx->at, 64);

		/* Write `matchingId` field */
		{
			const uint64_t tmp_val = (uint64_t) p_matchingId;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_Event_IoOperationCancelled(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_handle,
	const uint64_t p_matchingId)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 36);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `handle` field */
		_ALIGN(ctx->at, 32);

		/* Write `handle` field */
		{
			const uint32_t tmp_val = (uint32_t) p_handle;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `matchingId` field */
		_ALIGN(ctx->at, 64);

		/* Write `matchingId` field */
		{
			const uint64_t tmp_val = (uint64_t) p_matchingId;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_Event_IoOperationComplete(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_handle,
	const uint64_t p_bytesResult,
	const uint64_t p_matchingId)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 37);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `handle` field */
		_ALIGN(ctx->at, 32);

		/* Write `handle` field */
		{
			const uint32_t tmp_val = (uint32_t) p_handle;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `bytesResult` field */
		_ALIGN(ctx->at, 64);

		/* Write `bytesResult` field */
		{
			const uint64_t tmp_val = (uint64_t) p_bytesResult;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `matchingId` field */
		_ALIGN(ctx->at, 64);

		/* Write `matchingId` field */
		{
			const uint64_t tmp_val = (uint64_t) p_matchingId;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_Event_IoOperationIssued(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_handle,
	const uint64_t p_matchingId)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 38);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `handle` field */
		_ALIGN(ctx->at, 32);

		/* Write `handle` field */
		{
			const uint32_t tmp_val = (uint32_t) p_handle;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `matchingId` field */
		_ALIGN(ctx->at, 64);

		/* Write `matchingId` field */
		{
			const uint64_t tmp_val = (uint64_t) p_matchingId;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_Event_IoOperationTest(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_handle,
	const uint64_t p_matchingId)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 39);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `handle` field */
		_ALIGN(ctx->at, 32);

		/* Write `handle` field */
		{
			const uint32_t tmp_val = (uint32_t) p_handle;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `matchingId` field */
		_ALIGN(ctx->at, 64);

		/* Write `matchingId` field */
		{
			const uint64_t tmp_val = (uint64_t) p_matchingId;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_Event_IoReleaseLock(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_handle,
	const uint8_t p_lockType)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 40);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `handle` field */
		_ALIGN(ctx->at, 32);

		/* Write `handle` field */
		{
			const uint32_t tmp_val = (uint32_t) p_handle;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `lockType` field */
		_ALIGN(ctx->at, 8);

		/* Write `lockType` field */
		{
			const uint8_t tmp_val = (uint8_t) p_lockType;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}
	}
}

static void _serialize_er_default_Event_IoSeek(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_handle,
	const int64_t p_offsetRequest,
	const uint8_t p_whence,
	const uint64_t p_offsetResult)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 41);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `handle` field */
		_ALIGN(ctx->at, 32);

		/* Write `handle` field */
		{
			const uint32_t tmp_val = (uint32_t) p_handle;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `offsetRequest` field */
		_ALIGN(ctx->at, 64);

		/* Write `offsetRequest` field */
		{
			const uint64_t tmp_val = (uint64_t) p_offsetRequest;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `whence` field */
		_ALIGN(ctx->at, 8);

		/* Write `whence` field */
		{
			const uint8_t tmp_val = (uint8_t) p_whence;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}

		/* Align for `offsetResult` field */
		_ALIGN(ctx->at, 64);

		/* Write `offsetResult` field */
		{
			const uint64_t tmp_val = (uint64_t) p_offsetResult;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_Event_IoTryLock(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_handle,
	const uint8_t p_lockType)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 42);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `handle` field */
		_ALIGN(ctx->at, 32);

		/* Write `handle` field */
		{
			const uint32_t tmp_val = (uint32_t) p_handle;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `lockType` field */
		_ALIGN(ctx->at, 8);

		/* Write `lockType` field */
		{
			const uint8_t tmp_val = (uint8_t) p_lockType;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}
	}
}

static void _serialize_er_default_Event_Leave(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_region)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 43);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `region` field */
		_ALIGN(ctx->at, 32);

		/* Write `region` field */
		{
			const uint32_t tmp_val = (uint32_t) p_region;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_Event_MeasurementOnOff(void * const vctx,
	const uint64_t p_locationID,
	const uint8_t p_measurementMode)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 44);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `measurementMode` field */
		_ALIGN(ctx->at, 8);

		/* Write `measurementMode` field */
		{
			const uint8_t tmp_val = (uint8_t) p_measurementMode;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}
	}
}

static void _serialize_er_default_Event_Metric(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_metric,
	const uint8_t p_numberOfMetrics)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 45);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `metric` field */
		_ALIGN(ctx->at, 32);

		/* Write `metric` field */
		{
			const uint32_t tmp_val = (uint32_t) p_metric;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `numberOfMetrics` field */
		_ALIGN(ctx->at, 8);

		/* Write `numberOfMetrics` field */
		{
			const uint8_t tmp_val = (uint8_t) p_numberOfMetrics;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}
	}
}

static void _serialize_er_default_Event_MpiCollectiveBegin(void * const vctx,
	const uint64_t p_locationID)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 46);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_Event_MpiCollectiveEnd(void * const vctx,
	const uint64_t p_locationID,
	const uint8_t p_collectiveOp,
	const uint32_t p_communicator,
	const uint32_t p_root,
	const uint64_t p_sizeSent,
	const uint64_t p_sizeReceived)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 47);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `collectiveOp` field */
		_ALIGN(ctx->at, 8);

		/* Write `collectiveOp` field */
		{
			const uint8_t tmp_val = (uint8_t) p_collectiveOp;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}

		/* Align for `communicator` field */
		_ALIGN(ctx->at, 32);

		/* Write `communicator` field */
		{
			const uint32_t tmp_val = (uint32_t) p_communicator;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `root` field */
		_ALIGN(ctx->at, 32);

		/* Write `root` field */
		{
			const uint32_t tmp_val = (uint32_t) p_root;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `sizeSent` field */
		_ALIGN(ctx->at, 64);

		/* Write `sizeSent` field */
		{
			const uint64_t tmp_val = (uint64_t) p_sizeSent;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `sizeReceived` field */
		_ALIGN(ctx->at, 64);

		/* Write `sizeReceived` field */
		{
			const uint64_t tmp_val = (uint64_t) p_sizeReceived;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_Event_MpiIrecv(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_receiver,
	const uint32_t p_communicator,
	const uint32_t p_msgTag,
	const uint64_t p_msgLength,
	const uint64_t p_requestID)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 48);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `receiver` field */
		_ALIGN(ctx->at, 32);

		/* Write `receiver` field */
		{
			const uint32_t tmp_val = (uint32_t) p_receiver;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `communicator` field */
		_ALIGN(ctx->at, 32);

		/* Write `communicator` field */
		{
			const uint32_t tmp_val = (uint32_t) p_communicator;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `msgTag` field */
		_ALIGN(ctx->at, 32);

		/* Write `msgTag` field */
		{
			const uint32_t tmp_val = (uint32_t) p_msgTag;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `msgLength` field */
		_ALIGN(ctx->at, 64);

		/* Write `msgLength` field */
		{
			const uint64_t tmp_val = (uint64_t) p_msgLength;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `requestID` field */
		_ALIGN(ctx->at, 64);

		/* Write `requestID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_requestID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_Event_MpiIrecvRequest(void * const vctx,
	const uint64_t p_locationID,
	const uint64_t p_requestID)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 49);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `requestID` field */
		_ALIGN(ctx->at, 64);

		/* Write `requestID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_requestID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_Event_MpiIsend(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_receiver,
	const uint32_t p_communicator,
	const uint32_t p_msgTag,
	const uint64_t p_msgLength,
	const uint64_t p_requestID)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 50);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `receiver` field */
		_ALIGN(ctx->at, 32);

		/* Write `receiver` field */
		{
			const uint32_t tmp_val = (uint32_t) p_receiver;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `communicator` field */
		_ALIGN(ctx->at, 32);

		/* Write `communicator` field */
		{
			const uint32_t tmp_val = (uint32_t) p_communicator;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `msgTag` field */
		_ALIGN(ctx->at, 32);

		/* Write `msgTag` field */
		{
			const uint32_t tmp_val = (uint32_t) p_msgTag;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `msgLength` field */
		_ALIGN(ctx->at, 64);

		/* Write `msgLength` field */
		{
			const uint64_t tmp_val = (uint64_t) p_msgLength;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `requestID` field */
		_ALIGN(ctx->at, 64);

		/* Write `requestID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_requestID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_Event_MpiIsendComplete(void * const vctx,
	const uint64_t p_locationID,
	const uint64_t p_requestID)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 51);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `requestID` field */
		_ALIGN(ctx->at, 64);

		/* Write `requestID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_requestID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_Event_MpiRecv(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_sender,
	const uint32_t p_communicator,
	const uint32_t p_msgTag,
	const uint64_t p_msgLength)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 52);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `sender` field */
		_ALIGN(ctx->at, 32);

		/* Write `sender` field */
		{
			const uint32_t tmp_val = (uint32_t) p_sender;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `communicator` field */
		_ALIGN(ctx->at, 32);

		/* Write `communicator` field */
		{
			const uint32_t tmp_val = (uint32_t) p_communicator;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `msgTag` field */
		_ALIGN(ctx->at, 32);

		/* Write `msgTag` field */
		{
			const uint32_t tmp_val = (uint32_t) p_msgTag;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `msgLength` field */
		_ALIGN(ctx->at, 64);

		/* Write `msgLength` field */
		{
			const uint64_t tmp_val = (uint64_t) p_msgLength;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_Event_MpiRequestCancelled(void * const vctx,
	const uint64_t p_locationID,
	const uint64_t p_requestID)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 53);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `requestID` field */
		_ALIGN(ctx->at, 64);

		/* Write `requestID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_requestID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_Event_MpiRequestTest(void * const vctx,
	const uint64_t p_locationID,
	const uint64_t p_requestID)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 54);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `requestID` field */
		_ALIGN(ctx->at, 64);

		/* Write `requestID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_requestID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_Event_MpiSend(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_receiver,
	const uint32_t p_communicator,
	const uint32_t p_msgTag,
	const uint64_t p_msgLength)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 55);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `receiver` field */
		_ALIGN(ctx->at, 32);

		/* Write `receiver` field */
		{
			const uint32_t tmp_val = (uint32_t) p_receiver;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `communicator` field */
		_ALIGN(ctx->at, 32);

		/* Write `communicator` field */
		{
			const uint32_t tmp_val = (uint32_t) p_communicator;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `msgTag` field */
		_ALIGN(ctx->at, 32);

		/* Write `msgTag` field */
		{
			const uint32_t tmp_val = (uint32_t) p_msgTag;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `msgLength` field */
		_ALIGN(ctx->at, 64);

		/* Write `msgLength` field */
		{
			const uint64_t tmp_val = (uint64_t) p_msgLength;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_Event_OmpAcquireLock(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_lockID,
	const uint32_t p_acquisitionOrder)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 56);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `lockID` field */
		_ALIGN(ctx->at, 32);

		/* Write `lockID` field */
		{
			const uint32_t tmp_val = (uint32_t) p_lockID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `acquisitionOrder` field */
		_ALIGN(ctx->at, 32);

		/* Write `acquisitionOrder` field */
		{
			const uint32_t tmp_val = (uint32_t) p_acquisitionOrder;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_Event_OmpFork(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_numberOfRequestedThreads)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 57);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `numberOfRequestedThreads` field */
		_ALIGN(ctx->at, 32);

		/* Write `numberOfRequestedThreads` field */
		{
			const uint32_t tmp_val = (uint32_t) p_numberOfRequestedThreads;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_Event_OmpJoin(void * const vctx,
	const uint64_t p_locationID)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 58);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_Event_OmpReleaseLock(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_lockID,
	const uint32_t p_acquisitionOrder)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 59);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `lockID` field */
		_ALIGN(ctx->at, 32);

		/* Write `lockID` field */
		{
			const uint32_t tmp_val = (uint32_t) p_lockID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `acquisitionOrder` field */
		_ALIGN(ctx->at, 32);

		/* Write `acquisitionOrder` field */
		{
			const uint32_t tmp_val = (uint32_t) p_acquisitionOrder;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_Event_OmpTaskComplete(void * const vctx,
	const uint64_t p_locationID,
	const uint64_t p_taskID)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 60);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `taskID` field */
		_ALIGN(ctx->at, 64);

		/* Write `taskID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_taskID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_Event_OmpTaskCreate(void * const vctx,
	const uint64_t p_locationID,
	const uint64_t p_taskID)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 61);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `taskID` field */
		_ALIGN(ctx->at, 64);

		/* Write `taskID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_taskID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_Event_OmpTaskSwitch(void * const vctx,
	const uint64_t p_locationID,
	const uint64_t p_taskID)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 62);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `taskID` field */
		_ALIGN(ctx->at, 64);

		/* Write `taskID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_taskID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_Event_ParameterInt(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_parameter,
	const int64_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 63);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `parameter` field */
		_ALIGN(ctx->at, 32);

		/* Write `parameter` field */
		{
			const uint32_t tmp_val = (uint32_t) p_parameter;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `value` field */
		_ALIGN(ctx->at, 64);

		/* Write `value` field */
		{
			const uint64_t tmp_val = (uint64_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_Event_ParameterString(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_parameter,
	const uint32_t p_stringID)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 64);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `parameter` field */
		_ALIGN(ctx->at, 32);

		/* Write `parameter` field */
		{
			const uint32_t tmp_val = (uint32_t) p_parameter;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `stringID` field */
		_ALIGN(ctx->at, 32);

		/* Write `stringID` field */
		{
			const uint32_t tmp_val = (uint32_t) p_stringID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_Event_ParameterUnsignedInt(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_parameter,
	const uint64_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 65);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `parameter` field */
		_ALIGN(ctx->at, 32);

		/* Write `parameter` field */
		{
			const uint32_t tmp_val = (uint32_t) p_parameter;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `value` field */
		_ALIGN(ctx->at, 64);

		/* Write `value` field */
		{
			const uint64_t tmp_val = (uint64_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_Event_ProgramArgument(void * const vctx,
	const uint32_t p_programArgument)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 66);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `programArgument` field */
		_ALIGN(ctx->at, 32);

		/* Write `programArgument` field */
		{
			const uint32_t tmp_val = (uint32_t) p_programArgument;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_Event_ProgramBegin(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_programName)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 67);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `programName` field */
		_ALIGN(ctx->at, 32);

		/* Write `programName` field */
		{
			const uint32_t tmp_val = (uint32_t) p_programName;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_Event_ProgramEnd(void * const vctx,
	const uint64_t p_locationID,
	const int64_t p_exitStatus)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 68);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `exitStatus` field */
		_ALIGN(ctx->at, 64);

		/* Write `exitStatus` field */
		{
			const uint64_t tmp_val = (uint64_t) p_exitStatus;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_Event_RmaAcquireLock(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_win,
	const uint32_t p_remote,
	const uint64_t p_lockId,
	const uint8_t p_lockType)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 69);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `win` field */
		_ALIGN(ctx->at, 32);

		/* Write `win` field */
		{
			const uint32_t tmp_val = (uint32_t) p_win;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `remote` field */
		_ALIGN(ctx->at, 32);

		/* Write `remote` field */
		{
			const uint32_t tmp_val = (uint32_t) p_remote;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `lockId` field */
		_ALIGN(ctx->at, 64);

		/* Write `lockId` field */
		{
			const uint64_t tmp_val = (uint64_t) p_lockId;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `lockType` field */
		_ALIGN(ctx->at, 8);

		/* Write `lockType` field */
		{
			const uint8_t tmp_val = (uint8_t) p_lockType;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}
	}
}

static void _serialize_er_default_Event_RmaAtomic(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_win,
	const uint32_t p_remote,
	const uint8_t p_type,
	const uint64_t p_bytesSent,
	const uint64_t p_bytesReceived,
	const uint64_t p_matchingId)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 70);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `win` field */
		_ALIGN(ctx->at, 32);

		/* Write `win` field */
		{
			const uint32_t tmp_val = (uint32_t) p_win;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `remote` field */
		_ALIGN(ctx->at, 32);

		/* Write `remote` field */
		{
			const uint32_t tmp_val = (uint32_t) p_remote;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `type` field */
		_ALIGN(ctx->at, 8);

		/* Write `type` field */
		{
			const uint8_t tmp_val = (uint8_t) p_type;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}

		/* Align for `bytesSent` field */
		_ALIGN(ctx->at, 64);

		/* Write `bytesSent` field */
		{
			const uint64_t tmp_val = (uint64_t) p_bytesSent;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `bytesReceived` field */
		_ALIGN(ctx->at, 64);

		/* Write `bytesReceived` field */
		{
			const uint64_t tmp_val = (uint64_t) p_bytesReceived;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `matchingId` field */
		_ALIGN(ctx->at, 64);

		/* Write `matchingId` field */
		{
			const uint64_t tmp_val = (uint64_t) p_matchingId;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_Event_RmaCollectiveBegin(void * const vctx,
	const uint64_t p_locationID)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 71);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_Event_RmaCollectiveEnd(void * const vctx,
	const uint64_t p_locationID,
	const uint8_t p_collectiveOp,
	const uint32_t p_syncLevel,
	const uint32_t p_win,
	const uint32_t p_root,
	const uint64_t p_bytesSent,
	const uint64_t p_bytesReceived)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 72);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `collectiveOp` field */
		_ALIGN(ctx->at, 8);

		/* Write `collectiveOp` field */
		{
			const uint8_t tmp_val = (uint8_t) p_collectiveOp;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}

		/* Align for `syncLevel` field */
		_ALIGN(ctx->at, 32);

		/* Write `syncLevel` field */
		{
			const uint32_t tmp_val = (uint32_t) p_syncLevel;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `win` field */
		_ALIGN(ctx->at, 32);

		/* Write `win` field */
		{
			const uint32_t tmp_val = (uint32_t) p_win;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `root` field */
		_ALIGN(ctx->at, 32);

		/* Write `root` field */
		{
			const uint32_t tmp_val = (uint32_t) p_root;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `bytesSent` field */
		_ALIGN(ctx->at, 64);

		/* Write `bytesSent` field */
		{
			const uint64_t tmp_val = (uint64_t) p_bytesSent;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `bytesReceived` field */
		_ALIGN(ctx->at, 64);

		/* Write `bytesReceived` field */
		{
			const uint64_t tmp_val = (uint64_t) p_bytesReceived;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_Event_RmaGet(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_win,
	const uint32_t p_remote,
	const uint64_t p_bytes,
	const uint64_t p_matchingId)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 73);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `win` field */
		_ALIGN(ctx->at, 32);

		/* Write `win` field */
		{
			const uint32_t tmp_val = (uint32_t) p_win;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `remote` field */
		_ALIGN(ctx->at, 32);

		/* Write `remote` field */
		{
			const uint32_t tmp_val = (uint32_t) p_remote;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `bytes` field */
		_ALIGN(ctx->at, 64);

		/* Write `bytes` field */
		{
			const uint64_t tmp_val = (uint64_t) p_bytes;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `matchingId` field */
		_ALIGN(ctx->at, 64);

		/* Write `matchingId` field */
		{
			const uint64_t tmp_val = (uint64_t) p_matchingId;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_Event_RmaGroupSync(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_syncLevel,
	const uint32_t p_win,
	const uint32_t p_group)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 74);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `syncLevel` field */
		_ALIGN(ctx->at, 32);

		/* Write `syncLevel` field */
		{
			const uint32_t tmp_val = (uint32_t) p_syncLevel;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `win` field */
		_ALIGN(ctx->at, 32);

		/* Write `win` field */
		{
			const uint32_t tmp_val = (uint32_t) p_win;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `group` field */
		_ALIGN(ctx->at, 32);

		/* Write `group` field */
		{
			const uint32_t tmp_val = (uint32_t) p_group;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_Event_RmaOpCompleteBlocking(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_win,
	const uint64_t p_matchingId)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 75);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `win` field */
		_ALIGN(ctx->at, 32);

		/* Write `win` field */
		{
			const uint32_t tmp_val = (uint32_t) p_win;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `matchingId` field */
		_ALIGN(ctx->at, 64);

		/* Write `matchingId` field */
		{
			const uint64_t tmp_val = (uint64_t) p_matchingId;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_Event_RmaOpCompleteNonBlocking(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_win,
	const uint64_t p_matchingId)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 76);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `win` field */
		_ALIGN(ctx->at, 32);

		/* Write `win` field */
		{
			const uint32_t tmp_val = (uint32_t) p_win;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `matchingId` field */
		_ALIGN(ctx->at, 64);

		/* Write `matchingId` field */
		{
			const uint64_t tmp_val = (uint64_t) p_matchingId;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_Event_RmaOpCompleteRemote(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_win,
	const uint64_t p_matchingId)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 77);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `win` field */
		_ALIGN(ctx->at, 32);

		/* Write `win` field */
		{
			const uint32_t tmp_val = (uint32_t) p_win;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `matchingId` field */
		_ALIGN(ctx->at, 64);

		/* Write `matchingId` field */
		{
			const uint64_t tmp_val = (uint64_t) p_matchingId;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_Event_RmaOpTest(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_win,
	const uint64_t p_matchingId)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 78);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `win` field */
		_ALIGN(ctx->at, 32);

		/* Write `win` field */
		{
			const uint32_t tmp_val = (uint32_t) p_win;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `matchingId` field */
		_ALIGN(ctx->at, 64);

		/* Write `matchingId` field */
		{
			const uint64_t tmp_val = (uint64_t) p_matchingId;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_Event_RmaPut(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_win,
	const uint32_t p_remote,
	const uint64_t p_bytes,
	const uint64_t p_matchingId)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 79);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `win` field */
		_ALIGN(ctx->at, 32);

		/* Write `win` field */
		{
			const uint32_t tmp_val = (uint32_t) p_win;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `remote` field */
		_ALIGN(ctx->at, 32);

		/* Write `remote` field */
		{
			const uint32_t tmp_val = (uint32_t) p_remote;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `bytes` field */
		_ALIGN(ctx->at, 64);

		/* Write `bytes` field */
		{
			const uint64_t tmp_val = (uint64_t) p_bytes;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `matchingId` field */
		_ALIGN(ctx->at, 64);

		/* Write `matchingId` field */
		{
			const uint64_t tmp_val = (uint64_t) p_matchingId;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_Event_RmaReleaseLock(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_win,
	const uint32_t p_remote,
	const uint64_t p_lockId)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 80);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `win` field */
		_ALIGN(ctx->at, 32);

		/* Write `win` field */
		{
			const uint32_t tmp_val = (uint32_t) p_win;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `remote` field */
		_ALIGN(ctx->at, 32);

		/* Write `remote` field */
		{
			const uint32_t tmp_val = (uint32_t) p_remote;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `lockId` field */
		_ALIGN(ctx->at, 64);

		/* Write `lockId` field */
		{
			const uint64_t tmp_val = (uint64_t) p_lockId;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_Event_RmaRequestLock(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_win,
	const uint32_t p_remote,
	const uint64_t p_lockId,
	const uint8_t p_lockType)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 81);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `win` field */
		_ALIGN(ctx->at, 32);

		/* Write `win` field */
		{
			const uint32_t tmp_val = (uint32_t) p_win;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `remote` field */
		_ALIGN(ctx->at, 32);

		/* Write `remote` field */
		{
			const uint32_t tmp_val = (uint32_t) p_remote;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `lockId` field */
		_ALIGN(ctx->at, 64);

		/* Write `lockId` field */
		{
			const uint64_t tmp_val = (uint64_t) p_lockId;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `lockType` field */
		_ALIGN(ctx->at, 8);

		/* Write `lockType` field */
		{
			const uint8_t tmp_val = (uint8_t) p_lockType;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}
	}
}

static void _serialize_er_default_Event_RmaSync(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_win,
	const uint32_t p_remote,
	const uint8_t p_syncType)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 82);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `win` field */
		_ALIGN(ctx->at, 32);

		/* Write `win` field */
		{
			const uint32_t tmp_val = (uint32_t) p_win;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `remote` field */
		_ALIGN(ctx->at, 32);

		/* Write `remote` field */
		{
			const uint32_t tmp_val = (uint32_t) p_remote;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `syncType` field */
		_ALIGN(ctx->at, 8);

		/* Write `syncType` field */
		{
			const uint8_t tmp_val = (uint8_t) p_syncType;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}
	}
}

static void _serialize_er_default_Event_RmaTryLock(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_win,
	const uint32_t p_remote,
	const uint64_t p_lockId,
	const uint8_t p_lockType)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 83);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `win` field */
		_ALIGN(ctx->at, 32);

		/* Write `win` field */
		{
			const uint32_t tmp_val = (uint32_t) p_win;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `remote` field */
		_ALIGN(ctx->at, 32);

		/* Write `remote` field */
		{
			const uint32_t tmp_val = (uint32_t) p_remote;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `lockId` field */
		_ALIGN(ctx->at, 64);

		/* Write `lockId` field */
		{
			const uint64_t tmp_val = (uint64_t) p_lockId;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `lockType` field */
		_ALIGN(ctx->at, 8);

		/* Write `lockType` field */
		{
			const uint8_t tmp_val = (uint8_t) p_lockType;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}
	}
}

static void _serialize_er_default_Event_RmaWaitChange(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_win)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 84);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `win` field */
		_ALIGN(ctx->at, 32);

		/* Write `win` field */
		{
			const uint32_t tmp_val = (uint32_t) p_win;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_Event_RmaWinCreate(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_win)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 85);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `win` field */
		_ALIGN(ctx->at, 32);

		/* Write `win` field */
		{
			const uint32_t tmp_val = (uint32_t) p_win;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_Event_RmaWinDestroy(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_win)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 86);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `win` field */
		_ALIGN(ctx->at, 32);

		/* Write `win` field */
		{
			const uint32_t tmp_val = (uint32_t) p_win;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_Event_ThreadAcquireLock(void * const vctx,
	const uint64_t p_locationID,
	const uint8_t p_model,
	const uint32_t p_lockID,
	const uint32_t p_acquisitionOrder)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 87);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `model` field */
		_ALIGN(ctx->at, 8);

		/* Write `model` field */
		{
			const uint8_t tmp_val = (uint8_t) p_model;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}

		/* Align for `lockID` field */
		_ALIGN(ctx->at, 32);

		/* Write `lockID` field */
		{
			const uint32_t tmp_val = (uint32_t) p_lockID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `acquisitionOrder` field */
		_ALIGN(ctx->at, 32);

		/* Write `acquisitionOrder` field */
		{
			const uint32_t tmp_val = (uint32_t) p_acquisitionOrder;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_Event_ThreadBegin(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_threadContingent,
	const uint64_t p_sequenceCount)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 88);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `threadContingent` field */
		_ALIGN(ctx->at, 32);

		/* Write `threadContingent` field */
		{
			const uint32_t tmp_val = (uint32_t) p_threadContingent;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `sequenceCount` field */
		_ALIGN(ctx->at, 64);

		/* Write `sequenceCount` field */
		{
			const uint64_t tmp_val = (uint64_t) p_sequenceCount;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_Event_ThreadCreate(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_threadContingent,
	const uint64_t p_sequenceCount)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 89);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `threadContingent` field */
		_ALIGN(ctx->at, 32);

		/* Write `threadContingent` field */
		{
			const uint32_t tmp_val = (uint32_t) p_threadContingent;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `sequenceCount` field */
		_ALIGN(ctx->at, 64);

		/* Write `sequenceCount` field */
		{
			const uint64_t tmp_val = (uint64_t) p_sequenceCount;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_Event_ThreadEnd(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_threadContingent,
	const uint64_t p_sequenceCount)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 90);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `threadContingent` field */
		_ALIGN(ctx->at, 32);

		/* Write `threadContingent` field */
		{
			const uint32_t tmp_val = (uint32_t) p_threadContingent;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `sequenceCount` field */
		_ALIGN(ctx->at, 64);

		/* Write `sequenceCount` field */
		{
			const uint64_t tmp_val = (uint64_t) p_sequenceCount;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_Event_ThreadFork(void * const vctx,
	const uint64_t p_locationID,
	const uint8_t p_model,
	const uint32_t p_matchnumberOfRequestedThreadsingId)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 91);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `model` field */
		_ALIGN(ctx->at, 8);

		/* Write `model` field */
		{
			const uint8_t tmp_val = (uint8_t) p_model;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}

		/* Align for `matchnumberOfRequestedThreadsingId` field */
		_ALIGN(ctx->at, 32);

		/* Write `matchnumberOfRequestedThreadsingId` field */
		{
			const uint32_t tmp_val = (uint32_t) p_matchnumberOfRequestedThreadsingId;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_Event_ThreadJoin(void * const vctx,
	const uint64_t p_locationID,
	const uint8_t p_model)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 92);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `model` field */
		_ALIGN(ctx->at, 8);

		/* Write `model` field */
		{
			const uint8_t tmp_val = (uint8_t) p_model;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}
	}
}

static void _serialize_er_default_Event_ThreadReleaseLock(void * const vctx,
	const uint64_t p_locationID,
	const uint8_t p_model,
	const uint32_t p_lockID,
	const uint32_t p_acquisitionOrder)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 93);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `model` field */
		_ALIGN(ctx->at, 8);

		/* Write `model` field */
		{
			const uint8_t tmp_val = (uint8_t) p_model;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}

		/* Align for `lockID` field */
		_ALIGN(ctx->at, 32);

		/* Write `lockID` field */
		{
			const uint32_t tmp_val = (uint32_t) p_lockID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `acquisitionOrder` field */
		_ALIGN(ctx->at, 32);

		/* Write `acquisitionOrder` field */
		{
			const uint32_t tmp_val = (uint32_t) p_acquisitionOrder;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_Event_ThreadTaskComplete(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_threadTeam,
	const uint32_t p_creatingThread,
	const uint32_t p_generationNumber)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 94);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `threadTeam` field */
		_ALIGN(ctx->at, 32);

		/* Write `threadTeam` field */
		{
			const uint32_t tmp_val = (uint32_t) p_threadTeam;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `creatingThread` field */
		_ALIGN(ctx->at, 32);

		/* Write `creatingThread` field */
		{
			const uint32_t tmp_val = (uint32_t) p_creatingThread;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `generationNumber` field */
		_ALIGN(ctx->at, 32);

		/* Write `generationNumber` field */
		{
			const uint32_t tmp_val = (uint32_t) p_generationNumber;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_Event_ThreadTaskCreate(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_threadTeam,
	const uint32_t p_creatingThread,
	const uint32_t p_generationNumber)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 95);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `threadTeam` field */
		_ALIGN(ctx->at, 32);

		/* Write `threadTeam` field */
		{
			const uint32_t tmp_val = (uint32_t) p_threadTeam;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `creatingThread` field */
		_ALIGN(ctx->at, 32);

		/* Write `creatingThread` field */
		{
			const uint32_t tmp_val = (uint32_t) p_creatingThread;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `generationNumber` field */
		_ALIGN(ctx->at, 32);

		/* Write `generationNumber` field */
		{
			const uint32_t tmp_val = (uint32_t) p_generationNumber;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_Event_ThreadTaskSwitch(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_threadTeam,
	const uint32_t p_creatingThread,
	const uint32_t p_generationNumber)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 96);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `threadTeam` field */
		_ALIGN(ctx->at, 32);

		/* Write `threadTeam` field */
		{
			const uint32_t tmp_val = (uint32_t) p_threadTeam;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `creatingThread` field */
		_ALIGN(ctx->at, 32);

		/* Write `creatingThread` field */
		{
			const uint32_t tmp_val = (uint32_t) p_creatingThread;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `generationNumber` field */
		_ALIGN(ctx->at, 32);

		/* Write `generationNumber` field */
		{
			const uint32_t tmp_val = (uint32_t) p_generationNumber;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_Event_ThreadTeamBegin(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_threadTeam)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 97);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `threadTeam` field */
		_ALIGN(ctx->at, 32);

		/* Write `threadTeam` field */
		{
			const uint32_t tmp_val = (uint32_t) p_threadTeam;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_Event_ThreadTeamEnd(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_threadTeam)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 98);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `threadTeam` field */
		_ALIGN(ctx->at, 32);

		/* Write `threadTeam` field */
		{
			const uint32_t tmp_val = (uint32_t) p_threadTeam;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_Event_ThreadWait(void * const vctx,
	const uint64_t p_locationID,
	const uint32_t p_threadContingent,
	const uint64_t p_sequenceCount)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 99);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `locationID` field */
		_ALIGN(ctx->at, 64);

		/* Write `locationID` field */
		{
			const uint64_t tmp_val = (uint64_t) p_locationID;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `threadContingent` field */
		_ALIGN(ctx->at, 32);

		/* Write `threadContingent` field */
		{
			const uint32_t tmp_val = (uint32_t) p_threadContingent;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `sequenceCount` field */
		_ALIGN(ctx->at, 64);

		/* Write `sequenceCount` field */
		{
			const uint64_t tmp_val = (uint64_t) p_sequenceCount;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_GlobalDefAttribute_Attribute(void * const vctx,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 100);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `value` field */
		_ALIGN(ctx->at, 32);

		/* Write `value` field */
		{
			const uint32_t tmp_val = (uint32_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_GlobalDefAttribute_CallingContext(void * const vctx,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 101);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `value` field */
		_ALIGN(ctx->at, 32);

		/* Write `value` field */
		{
			const uint32_t tmp_val = (uint32_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_GlobalDefAttribute_Comm(void * const vctx,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 102);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `value` field */
		_ALIGN(ctx->at, 32);

		/* Write `value` field */
		{
			const uint32_t tmp_val = (uint32_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_GlobalDefAttribute_Double(void * const vctx,
	const double p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 103);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `value` field */
		_ALIGN(ctx->at, 64);

		/* Write `value` field */
		{
			union _d2u d2u;

			d2u.f = p_value;
			{
				const uint64_t tmp_val = (uint64_t) d2u.u;

				memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
				ctx->at += 64;
			}
		}
	}
}

static void _serialize_er_default_GlobalDefAttribute_Float(void * const vctx,
	const float p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 104);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `value` field */
		_ALIGN(ctx->at, 32);

		/* Write `value` field */
		{
			union _f2u f2u;

			f2u.f = p_value;
			{
				const uint32_t tmp_val = (uint32_t) f2u.u;

				memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
				ctx->at += 32;
			}
		}
	}
}

static void _serialize_er_default_GlobalDefAttribute_Group(void * const vctx,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 105);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `value` field */
		_ALIGN(ctx->at, 32);

		/* Write `value` field */
		{
			const uint32_t tmp_val = (uint32_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_GlobalDefAttribute_Int16(void * const vctx,
	const int16_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 106);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 16);

		/* Align for `value` field */
		_ALIGN(ctx->at, 16);

		/* Write `value` field */
		{
			const uint16_t tmp_val = (uint16_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 16;
		}
	}
}

static void _serialize_er_default_GlobalDefAttribute_Int32(void * const vctx,
	const int32_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 107);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `value` field */
		_ALIGN(ctx->at, 32);

		/* Write `value` field */
		{
			const uint32_t tmp_val = (uint32_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_GlobalDefAttribute_Int64(void * const vctx,
	const int64_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 108);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `value` field */
		_ALIGN(ctx->at, 64);

		/* Write `value` field */
		{
			const uint64_t tmp_val = (uint64_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_GlobalDefAttribute_Int8(void * const vctx,
	const int8_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 109);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 8);

		/* Align for `value` field */
		_ALIGN(ctx->at, 8);

		/* Write `value` field */
		{
			const uint8_t tmp_val = (uint8_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}
	}
}

static void _serialize_er_default_GlobalDefAttribute_InterruptGenerator(void * const vctx,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 110);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `value` field */
		_ALIGN(ctx->at, 32);

		/* Write `value` field */
		{
			const uint32_t tmp_val = (uint32_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_GlobalDefAttribute_IoFile(void * const vctx,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 111);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `value` field */
		_ALIGN(ctx->at, 32);

		/* Write `value` field */
		{
			const uint32_t tmp_val = (uint32_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_GlobalDefAttribute_IoHandle(void * const vctx,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 112);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `value` field */
		_ALIGN(ctx->at, 32);

		/* Write `value` field */
		{
			const uint32_t tmp_val = (uint32_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_GlobalDefAttribute_Location(void * const vctx,
	const uint64_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 113);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `value` field */
		_ALIGN(ctx->at, 64);

		/* Write `value` field */
		{
			const uint64_t tmp_val = (uint64_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_GlobalDefAttribute_Metric(void * const vctx,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 114);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `value` field */
		_ALIGN(ctx->at, 32);

		/* Write `value` field */
		{
			const uint32_t tmp_val = (uint32_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_GlobalDefAttribute_Parameter(void * const vctx,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 115);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `value` field */
		_ALIGN(ctx->at, 32);

		/* Write `value` field */
		{
			const uint32_t tmp_val = (uint32_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_GlobalDefAttribute_Region(void * const vctx,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 116);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `value` field */
		_ALIGN(ctx->at, 32);

		/* Write `value` field */
		{
			const uint32_t tmp_val = (uint32_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_GlobalDefAttribute_RmaWin(void * const vctx,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 117);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `value` field */
		_ALIGN(ctx->at, 32);

		/* Write `value` field */
		{
			const uint32_t tmp_val = (uint32_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_GlobalDefAttribute_SourceCodeLocation(void * const vctx,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 118);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `value` field */
		_ALIGN(ctx->at, 32);

		/* Write `value` field */
		{
			const uint32_t tmp_val = (uint32_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_GlobalDefAttribute_String(void * const vctx,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 119);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `value` field */
		_ALIGN(ctx->at, 32);

		/* Write `value` field */
		{
			const uint32_t tmp_val = (uint32_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_GlobalDefAttribute_UInt16(void * const vctx,
	const uint16_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 120);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 16);

		/* Align for `value` field */
		_ALIGN(ctx->at, 16);

		/* Write `value` field */
		{
			const uint16_t tmp_val = (uint16_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 16;
		}
	}
}

static void _serialize_er_default_GlobalDefAttribute_UInt32(void * const vctx,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 121);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `value` field */
		_ALIGN(ctx->at, 32);

		/* Write `value` field */
		{
			const uint32_t tmp_val = (uint32_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_GlobalDefAttribute_UInt64(void * const vctx,
	const uint64_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 122);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `value` field */
		_ALIGN(ctx->at, 64);

		/* Write `value` field */
		{
			const uint64_t tmp_val = (uint64_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_GlobalDefAttribute_UInt8(void * const vctx,
	const uint8_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 123);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 8);

		/* Align for `value` field */
		_ALIGN(ctx->at, 8);

		/* Write `value` field */
		{
			const uint8_t tmp_val = (uint8_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}
	}
}

static void _serialize_er_default_GlobalDef_Attribute(void * const vctx,
	const uint32_t p_self,
	const uint32_t p_name,
	const uint32_t p_description,
	const uint8_t p_type)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 124);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `self` field */
		_ALIGN(ctx->at, 32);

		/* Write `self` field */
		{
			const uint32_t tmp_val = (uint32_t) p_self;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `name` field */
		_ALIGN(ctx->at, 32);

		/* Write `name` field */
		{
			const uint32_t tmp_val = (uint32_t) p_name;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `description` field */
		_ALIGN(ctx->at, 32);

		/* Write `description` field */
		{
			const uint32_t tmp_val = (uint32_t) p_description;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `type` field */
		_ALIGN(ctx->at, 8);

		/* Write `type` field */
		{
			const uint8_t tmp_val = (uint8_t) p_type;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}
	}
}

static void _serialize_er_default_GlobalDef_CallingContext(void * const vctx,
	const uint32_t p_self,
	const uint32_t p_region,
	const uint32_t p_sourceCodeLocation,
	const uint32_t p_parent)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 125);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `self` field */
		_ALIGN(ctx->at, 32);

		/* Write `self` field */
		{
			const uint32_t tmp_val = (uint32_t) p_self;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `region` field */
		_ALIGN(ctx->at, 32);

		/* Write `region` field */
		{
			const uint32_t tmp_val = (uint32_t) p_region;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `sourceCodeLocation` field */
		_ALIGN(ctx->at, 32);

		/* Write `sourceCodeLocation` field */
		{
			const uint32_t tmp_val = (uint32_t) p_sourceCodeLocation;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `parent` field */
		_ALIGN(ctx->at, 32);

		/* Write `parent` field */
		{
			const uint32_t tmp_val = (uint32_t) p_parent;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_GlobalDef_CallingContextProperty(void * const vctx,
	const uint32_t p_callingContext,
	const uint32_t p_name)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 126);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `callingContext` field */
		_ALIGN(ctx->at, 32);

		/* Write `callingContext` field */
		{
			const uint32_t tmp_val = (uint32_t) p_callingContext;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `name` field */
		_ALIGN(ctx->at, 32);

		/* Write `name` field */
		{
			const uint32_t tmp_val = (uint32_t) p_name;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_GlobalDef_Callpath(void * const vctx,
	const uint32_t p_self,
	const uint32_t p_parent,
	const uint32_t p_region)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 127);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `self` field */
		_ALIGN(ctx->at, 32);

		/* Write `self` field */
		{
			const uint32_t tmp_val = (uint32_t) p_self;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `parent` field */
		_ALIGN(ctx->at, 32);

		/* Write `parent` field */
		{
			const uint32_t tmp_val = (uint32_t) p_parent;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `region` field */
		_ALIGN(ctx->at, 32);

		/* Write `region` field */
		{
			const uint32_t tmp_val = (uint32_t) p_region;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_GlobalDef_CallpathParameter(void * const vctx,
	const uint32_t p_callpath,
	const uint32_t p_parameter)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 128);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `callpath` field */
		_ALIGN(ctx->at, 32);

		/* Write `callpath` field */
		{
			const uint32_t tmp_val = (uint32_t) p_callpath;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `parameter` field */
		_ALIGN(ctx->at, 32);

		/* Write `parameter` field */
		{
			const uint32_t tmp_val = (uint32_t) p_parameter;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_GlobalDef_Callsite(void * const vctx,
	const uint32_t p_self,
	const uint32_t p_sourceFile,
	const uint32_t p_lineNumber,
	const uint32_t p_enteredRegion,
	const uint32_t p_leftRegion)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 129);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `self` field */
		_ALIGN(ctx->at, 32);

		/* Write `self` field */
		{
			const uint32_t tmp_val = (uint32_t) p_self;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `sourceFile` field */
		_ALIGN(ctx->at, 32);

		/* Write `sourceFile` field */
		{
			const uint32_t tmp_val = (uint32_t) p_sourceFile;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `lineNumber` field */
		_ALIGN(ctx->at, 32);

		/* Write `lineNumber` field */
		{
			const uint32_t tmp_val = (uint32_t) p_lineNumber;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `enteredRegion` field */
		_ALIGN(ctx->at, 32);

		/* Write `enteredRegion` field */
		{
			const uint32_t tmp_val = (uint32_t) p_enteredRegion;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `leftRegion` field */
		_ALIGN(ctx->at, 32);

		/* Write `leftRegion` field */
		{
			const uint32_t tmp_val = (uint32_t) p_leftRegion;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_GlobalDef_CartCoordinate(void * const vctx,
	const uint32_t p_cartTopology,
	const uint32_t p_rank,
	const uint32_t p___coordinates_len,
	const uint32_t * const p_coordinates)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 130);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `cartTopology` field */
		_ALIGN(ctx->at, 32);

		/* Write `cartTopology` field */
		{
			const uint32_t tmp_val = (uint32_t) p_cartTopology;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `rank` field */
		_ALIGN(ctx->at, 32);

		/* Write `rank` field */
		{
			const uint32_t tmp_val = (uint32_t) p_rank;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `__coordinates_len` field */
		_ALIGN(ctx->at, 8);

		/* Write `__coordinates_len` field */
		{
			const uint32_t tmp_val = (uint32_t) p___coordinates_len;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `coordinates` field */
		_ALIGN(ctx->at, 32);

		/* Write `coordinates` field */
		{
			uint32_t i;

			for (i = 0; i < (uint32_t) p___coordinates_len; ++i) {
				/* Align for `[i]` field */
				_ALIGN(ctx->at, 32);

				/* Write `[i]` field */
				{
					const uint32_t tmp_val = (uint32_t) p_coordinates[i];

					memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
					ctx->at += 32;
				}
			}
		}
	}
}

static void _serialize_er_default_GlobalDef_CartDimension(void * const vctx,
	const uint32_t p_self,
	const uint32_t p_name,
	const uint32_t p_size,
	const uint8_t p_cartPeriodicity)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 131);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `self` field */
		_ALIGN(ctx->at, 32);

		/* Write `self` field */
		{
			const uint32_t tmp_val = (uint32_t) p_self;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `name` field */
		_ALIGN(ctx->at, 32);

		/* Write `name` field */
		{
			const uint32_t tmp_val = (uint32_t) p_name;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `size` field */
		_ALIGN(ctx->at, 32);

		/* Write `size` field */
		{
			const uint32_t tmp_val = (uint32_t) p_size;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `cartPeriodicity` field */
		_ALIGN(ctx->at, 8);

		/* Write `cartPeriodicity` field */
		{
			const uint8_t tmp_val = (uint8_t) p_cartPeriodicity;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}
	}
}

static void _serialize_er_default_GlobalDef_CartTopology(void * const vctx,
	const uint32_t p_self,
	const uint32_t p_name,
	const uint32_t p_communicator,
	const uint32_t p___cartDimensions_len,
	const uint32_t * const p_cartDimensions)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 132);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `self` field */
		_ALIGN(ctx->at, 32);

		/* Write `self` field */
		{
			const uint32_t tmp_val = (uint32_t) p_self;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `name` field */
		_ALIGN(ctx->at, 32);

		/* Write `name` field */
		{
			const uint32_t tmp_val = (uint32_t) p_name;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `communicator` field */
		_ALIGN(ctx->at, 32);

		/* Write `communicator` field */
		{
			const uint32_t tmp_val = (uint32_t) p_communicator;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `__cartDimensions_len` field */
		_ALIGN(ctx->at, 8);

		/* Write `__cartDimensions_len` field */
		{
			const uint32_t tmp_val = (uint32_t) p___cartDimensions_len;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `cartDimensions` field */
		_ALIGN(ctx->at, 32);

		/* Write `cartDimensions` field */
		{
			uint32_t i;

			for (i = 0; i < (uint32_t) p___cartDimensions_len; ++i) {
				/* Align for `[i]` field */
				_ALIGN(ctx->at, 32);

				/* Write `[i]` field */
				{
					const uint32_t tmp_val = (uint32_t) p_cartDimensions[i];

					memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
					ctx->at += 32;
				}
			}
		}
	}
}

static void _serialize_er_default_GlobalDef_ClockProperties(void * const vctx,
	const uint64_t p_timerResolution,
	const uint64_t p_globalOffset,
	const uint64_t p_traceLength)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 133);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `timerResolution` field */
		_ALIGN(ctx->at, 64);

		/* Write `timerResolution` field */
		{
			const uint64_t tmp_val = (uint64_t) p_timerResolution;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `globalOffset` field */
		_ALIGN(ctx->at, 64);

		/* Write `globalOffset` field */
		{
			const uint64_t tmp_val = (uint64_t) p_globalOffset;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `traceLength` field */
		_ALIGN(ctx->at, 64);

		/* Write `traceLength` field */
		{
			const uint64_t tmp_val = (uint64_t) p_traceLength;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_GlobalDef_Comm(void * const vctx,
	const uint32_t p_self,
	const uint32_t p_name,
	const uint32_t p_group,
	const uint32_t p_parent)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 134);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `self` field */
		_ALIGN(ctx->at, 32);

		/* Write `self` field */
		{
			const uint32_t tmp_val = (uint32_t) p_self;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `name` field */
		_ALIGN(ctx->at, 32);

		/* Write `name` field */
		{
			const uint32_t tmp_val = (uint32_t) p_name;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `group` field */
		_ALIGN(ctx->at, 32);

		/* Write `group` field */
		{
			const uint32_t tmp_val = (uint32_t) p_group;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `parent` field */
		_ALIGN(ctx->at, 32);

		/* Write `parent` field */
		{
			const uint32_t tmp_val = (uint32_t) p_parent;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_GlobalDef_Group(void * const vctx,
	const uint32_t p_self,
	const uint32_t p_name,
	const uint8_t p_groupType,
	const uint8_t p_paradigm,
	const uint32_t p_groupFlags,
	const uint32_t p_numberOfMembers)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 135);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `self` field */
		_ALIGN(ctx->at, 32);

		/* Write `self` field */
		{
			const uint32_t tmp_val = (uint32_t) p_self;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `name` field */
		_ALIGN(ctx->at, 32);

		/* Write `name` field */
		{
			const uint32_t tmp_val = (uint32_t) p_name;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `groupType` field */
		_ALIGN(ctx->at, 8);

		/* Write `groupType` field */
		{
			const uint8_t tmp_val = (uint8_t) p_groupType;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}

		/* Align for `paradigm` field */
		_ALIGN(ctx->at, 8);

		/* Write `paradigm` field */
		{
			const uint8_t tmp_val = (uint8_t) p_paradigm;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}

		/* Align for `groupFlags` field */
		_ALIGN(ctx->at, 32);

		/* Write `groupFlags` field */
		{
			const uint32_t tmp_val = (uint32_t) p_groupFlags;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `numberOfMembers` field */
		_ALIGN(ctx->at, 32);

		/* Write `numberOfMembers` field */
		{
			const uint32_t tmp_val = (uint32_t) p_numberOfMembers;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_GlobalDef_GroupMember(void * const vctx,
	const uint32_t p_group,
	const uint32_t p_rank,
	const uint64_t p_location)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 136);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `group` field */
		_ALIGN(ctx->at, 32);

		/* Write `group` field */
		{
			const uint32_t tmp_val = (uint32_t) p_group;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `rank` field */
		_ALIGN(ctx->at, 32);

		/* Write `rank` field */
		{
			const uint32_t tmp_val = (uint32_t) p_rank;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `location` field */
		_ALIGN(ctx->at, 64);

		/* Write `location` field */
		{
			const uint64_t tmp_val = (uint64_t) p_location;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_GlobalDef_InterruptGenerator(void * const vctx,
	const uint32_t p_self,
	const uint32_t p_name,
	const uint8_t p_interruptGeneratorMode,
	const uint8_t p_base,
	const int64_t p_exponent,
	const uint64_t p_period)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 137);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `self` field */
		_ALIGN(ctx->at, 32);

		/* Write `self` field */
		{
			const uint32_t tmp_val = (uint32_t) p_self;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `name` field */
		_ALIGN(ctx->at, 32);

		/* Write `name` field */
		{
			const uint32_t tmp_val = (uint32_t) p_name;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `interruptGeneratorMode` field */
		_ALIGN(ctx->at, 8);

		/* Write `interruptGeneratorMode` field */
		{
			const uint8_t tmp_val = (uint8_t) p_interruptGeneratorMode;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}

		/* Align for `base` field */
		_ALIGN(ctx->at, 8);

		/* Write `base` field */
		{
			const uint8_t tmp_val = (uint8_t) p_base;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}

		/* Align for `exponent` field */
		_ALIGN(ctx->at, 64);

		/* Write `exponent` field */
		{
			const uint64_t tmp_val = (uint64_t) p_exponent;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `period` field */
		_ALIGN(ctx->at, 64);

		/* Write `period` field */
		{
			const uint64_t tmp_val = (uint64_t) p_period;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_GlobalDef_IoDirectory(void * const vctx,
	const uint32_t p_self,
	const uint32_t p_name,
	const uint32_t p_scope)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 138);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `self` field */
		_ALIGN(ctx->at, 32);

		/* Write `self` field */
		{
			const uint32_t tmp_val = (uint32_t) p_self;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `name` field */
		_ALIGN(ctx->at, 32);

		/* Write `name` field */
		{
			const uint32_t tmp_val = (uint32_t) p_name;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `scope` field */
		_ALIGN(ctx->at, 32);

		/* Write `scope` field */
		{
			const uint32_t tmp_val = (uint32_t) p_scope;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_GlobalDef_IoFileProperty(void * const vctx,
	const uint32_t p_ioFile,
	const uint32_t p_name)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 139);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `ioFile` field */
		_ALIGN(ctx->at, 32);

		/* Write `ioFile` field */
		{
			const uint32_t tmp_val = (uint32_t) p_ioFile;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `name` field */
		_ALIGN(ctx->at, 32);

		/* Write `name` field */
		{
			const uint32_t tmp_val = (uint32_t) p_name;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_GlobalDef_IoHandle(void * const vctx,
	const uint32_t p_self,
	const uint32_t p_name,
	const uint32_t p_file,
	const uint8_t p_ioParadigm,
	const uint32_t p_ioHandleFlags,
	const uint32_t p_comm,
	const uint32_t p_parent)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 140);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `self` field */
		_ALIGN(ctx->at, 32);

		/* Write `self` field */
		{
			const uint32_t tmp_val = (uint32_t) p_self;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `name` field */
		_ALIGN(ctx->at, 32);

		/* Write `name` field */
		{
			const uint32_t tmp_val = (uint32_t) p_name;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `file` field */
		_ALIGN(ctx->at, 32);

		/* Write `file` field */
		{
			const uint32_t tmp_val = (uint32_t) p_file;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `ioParadigm` field */
		_ALIGN(ctx->at, 8);

		/* Write `ioParadigm` field */
		{
			const uint8_t tmp_val = (uint8_t) p_ioParadigm;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}

		/* Align for `ioHandleFlags` field */
		_ALIGN(ctx->at, 32);

		/* Write `ioHandleFlags` field */
		{
			const uint32_t tmp_val = (uint32_t) p_ioHandleFlags;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `comm` field */
		_ALIGN(ctx->at, 32);

		/* Write `comm` field */
		{
			const uint32_t tmp_val = (uint32_t) p_comm;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `parent` field */
		_ALIGN(ctx->at, 32);

		/* Write `parent` field */
		{
			const uint32_t tmp_val = (uint32_t) p_parent;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_GlobalDef_IoParadigm(void * const vctx,
	const uint8_t p_self,
	const uint32_t p_identification,
	const uint32_t p_name,
	const uint8_t p_ioParadigmClass,
	const uint32_t p_ioParadigmFlags,
	const uint8_t p_numberOfProperties)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 141);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `self` field */
		_ALIGN(ctx->at, 8);

		/* Write `self` field */
		{
			const uint8_t tmp_val = (uint8_t) p_self;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}

		/* Align for `identification` field */
		_ALIGN(ctx->at, 32);

		/* Write `identification` field */
		{
			const uint32_t tmp_val = (uint32_t) p_identification;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `name` field */
		_ALIGN(ctx->at, 32);

		/* Write `name` field */
		{
			const uint32_t tmp_val = (uint32_t) p_name;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `ioParadigmClass` field */
		_ALIGN(ctx->at, 8);

		/* Write `ioParadigmClass` field */
		{
			const uint8_t tmp_val = (uint8_t) p_ioParadigmClass;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}

		/* Align for `ioParadigmFlags` field */
		_ALIGN(ctx->at, 32);

		/* Write `ioParadigmFlags` field */
		{
			const uint32_t tmp_val = (uint32_t) p_ioParadigmFlags;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `numberOfProperties` field */
		_ALIGN(ctx->at, 8);

		/* Write `numberOfProperties` field */
		{
			const uint8_t tmp_val = (uint8_t) p_numberOfProperties;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}
	}
}

static void _serialize_er_default_GlobalDef_IoParadigmProperty(void * const vctx,
	const uint8_t p_ioParadigm,
	const uint8_t p_ioParadigmProperty)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 142);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 8);

		/* Align for `ioParadigm` field */
		_ALIGN(ctx->at, 8);

		/* Write `ioParadigm` field */
		{
			const uint8_t tmp_val = (uint8_t) p_ioParadigm;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}

		/* Align for `ioParadigmProperty` field */
		_ALIGN(ctx->at, 8);

		/* Write `ioParadigmProperty` field */
		{
			const uint8_t tmp_val = (uint8_t) p_ioParadigmProperty;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}
	}
}

static void _serialize_er_default_GlobalDef_IoPreCreatedHandleState(void * const vctx,
	const uint32_t p_ioHandle,
	const uint8_t p_mode,
	const uint32_t p_statusFlags)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 143);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `ioHandle` field */
		_ALIGN(ctx->at, 32);

		/* Write `ioHandle` field */
		{
			const uint32_t tmp_val = (uint32_t) p_ioHandle;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `mode` field */
		_ALIGN(ctx->at, 8);

		/* Write `mode` field */
		{
			const uint8_t tmp_val = (uint8_t) p_mode;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}

		/* Align for `statusFlags` field */
		_ALIGN(ctx->at, 32);

		/* Write `statusFlags` field */
		{
			const uint32_t tmp_val = (uint32_t) p_statusFlags;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_GlobalDef_IoRegularFile(void * const vctx,
	const uint32_t p_self,
	const uint32_t p_name,
	const uint32_t p_scope)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 144);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `self` field */
		_ALIGN(ctx->at, 32);

		/* Write `self` field */
		{
			const uint32_t tmp_val = (uint32_t) p_self;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `name` field */
		_ALIGN(ctx->at, 32);

		/* Write `name` field */
		{
			const uint32_t tmp_val = (uint32_t) p_name;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `scope` field */
		_ALIGN(ctx->at, 32);

		/* Write `scope` field */
		{
			const uint32_t tmp_val = (uint32_t) p_scope;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_GlobalDef_Location(void * const vctx,
	const uint64_t p_self,
	const uint32_t p_name,
	const uint8_t p_locationType,
	const uint64_t p_numberOfEvents,
	const uint32_t p_locationGroup)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 145);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `self` field */
		_ALIGN(ctx->at, 64);

		/* Write `self` field */
		{
			const uint64_t tmp_val = (uint64_t) p_self;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `name` field */
		_ALIGN(ctx->at, 32);

		/* Write `name` field */
		{
			const uint32_t tmp_val = (uint32_t) p_name;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `locationType` field */
		_ALIGN(ctx->at, 8);

		/* Write `locationType` field */
		{
			const uint8_t tmp_val = (uint8_t) p_locationType;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}

		/* Align for `numberOfEvents` field */
		_ALIGN(ctx->at, 64);

		/* Write `numberOfEvents` field */
		{
			const uint64_t tmp_val = (uint64_t) p_numberOfEvents;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `locationGroup` field */
		_ALIGN(ctx->at, 32);

		/* Write `locationGroup` field */
		{
			const uint32_t tmp_val = (uint32_t) p_locationGroup;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_GlobalDef_LocationGroup(void * const vctx,
	const uint32_t p_self,
	const uint32_t p_name,
	const uint8_t p_locationGroupType,
	const uint32_t p_systemTreeParent)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 146);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `self` field */
		_ALIGN(ctx->at, 32);

		/* Write `self` field */
		{
			const uint32_t tmp_val = (uint32_t) p_self;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `name` field */
		_ALIGN(ctx->at, 32);

		/* Write `name` field */
		{
			const uint32_t tmp_val = (uint32_t) p_name;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `locationGroupType` field */
		_ALIGN(ctx->at, 8);

		/* Write `locationGroupType` field */
		{
			const uint8_t tmp_val = (uint8_t) p_locationGroupType;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}

		/* Align for `systemTreeParent` field */
		_ALIGN(ctx->at, 32);

		/* Write `systemTreeParent` field */
		{
			const uint32_t tmp_val = (uint32_t) p_systemTreeParent;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_GlobalDef_LocationGroupProperty(void * const vctx,
	const uint32_t p_locationGroup,
	const uint32_t p_name)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 147);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `locationGroup` field */
		_ALIGN(ctx->at, 32);

		/* Write `locationGroup` field */
		{
			const uint32_t tmp_val = (uint32_t) p_locationGroup;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `name` field */
		_ALIGN(ctx->at, 32);

		/* Write `name` field */
		{
			const uint32_t tmp_val = (uint32_t) p_name;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_GlobalDef_LocationProperty(void * const vctx,
	const uint64_t p_location,
	const uint32_t p_name)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 148);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `location` field */
		_ALIGN(ctx->at, 64);

		/* Write `location` field */
		{
			const uint64_t tmp_val = (uint64_t) p_location;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `name` field */
		_ALIGN(ctx->at, 32);

		/* Write `name` field */
		{
			const uint32_t tmp_val = (uint32_t) p_name;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_GlobalDef_MetricClass(void * const vctx,
	const uint32_t p_self,
	const uint32_t p___metricMembers_len,
	const uint32_t * const p_metricMembers,
	const uint8_t p_metricOccurrence,
	const uint8_t p_recorderKind)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 149);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `self` field */
		_ALIGN(ctx->at, 32);

		/* Write `self` field */
		{
			const uint32_t tmp_val = (uint32_t) p_self;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `__metricMembers_len` field */
		_ALIGN(ctx->at, 8);

		/* Write `__metricMembers_len` field */
		{
			const uint32_t tmp_val = (uint32_t) p___metricMembers_len;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `metricMembers` field */
		_ALIGN(ctx->at, 32);

		/* Write `metricMembers` field */
		{
			uint32_t i;

			for (i = 0; i < (uint32_t) p___metricMembers_len; ++i) {
				/* Align for `[i]` field */
				_ALIGN(ctx->at, 32);

				/* Write `[i]` field */
				{
					const uint32_t tmp_val = (uint32_t) p_metricMembers[i];

					memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
					ctx->at += 32;
				}
			}
		}

		/* Align for `metricOccurrence` field */
		_ALIGN(ctx->at, 8);

		/* Write `metricOccurrence` field */
		{
			const uint8_t tmp_val = (uint8_t) p_metricOccurrence;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}

		/* Align for `recorderKind` field */
		_ALIGN(ctx->at, 8);

		/* Write `recorderKind` field */
		{
			const uint8_t tmp_val = (uint8_t) p_recorderKind;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}
	}
}

static void _serialize_er_default_GlobalDef_MetricClassRecorder(void * const vctx,
	const uint32_t p_metric,
	const uint64_t p_recorder)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 150);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `metric` field */
		_ALIGN(ctx->at, 32);

		/* Write `metric` field */
		{
			const uint32_t tmp_val = (uint32_t) p_metric;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `recorder` field */
		_ALIGN(ctx->at, 64);

		/* Write `recorder` field */
		{
			const uint64_t tmp_val = (uint64_t) p_recorder;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_GlobalDef_MetricInstance(void * const vctx,
	const uint32_t p_self,
	const uint32_t p_metricClass,
	const uint64_t p_recorder,
	const uint8_t p_metricScope,
	const uint64_t p_scope)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 151);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `self` field */
		_ALIGN(ctx->at, 32);

		/* Write `self` field */
		{
			const uint32_t tmp_val = (uint32_t) p_self;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `metricClass` field */
		_ALIGN(ctx->at, 32);

		/* Write `metricClass` field */
		{
			const uint32_t tmp_val = (uint32_t) p_metricClass;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `recorder` field */
		_ALIGN(ctx->at, 64);

		/* Write `recorder` field */
		{
			const uint64_t tmp_val = (uint64_t) p_recorder;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `metricScope` field */
		_ALIGN(ctx->at, 8);

		/* Write `metricScope` field */
		{
			const uint8_t tmp_val = (uint8_t) p_metricScope;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}

		/* Align for `scope` field */
		_ALIGN(ctx->at, 64);

		/* Write `scope` field */
		{
			const uint64_t tmp_val = (uint64_t) p_scope;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_GlobalDef_MetricMember(void * const vctx,
	const uint32_t p_self,
	const uint32_t p_name,
	const uint32_t p_description,
	const uint8_t p_metricType,
	const uint8_t p_metricMode,
	const uint8_t p_valueType,
	const uint8_t p_base,
	const int64_t p_exponent,
	const uint32_t p_unit)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 152);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `self` field */
		_ALIGN(ctx->at, 32);

		/* Write `self` field */
		{
			const uint32_t tmp_val = (uint32_t) p_self;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `name` field */
		_ALIGN(ctx->at, 32);

		/* Write `name` field */
		{
			const uint32_t tmp_val = (uint32_t) p_name;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `description` field */
		_ALIGN(ctx->at, 32);

		/* Write `description` field */
		{
			const uint32_t tmp_val = (uint32_t) p_description;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `metricType` field */
		_ALIGN(ctx->at, 8);

		/* Write `metricType` field */
		{
			const uint8_t tmp_val = (uint8_t) p_metricType;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}

		/* Align for `metricMode` field */
		_ALIGN(ctx->at, 8);

		/* Write `metricMode` field */
		{
			const uint8_t tmp_val = (uint8_t) p_metricMode;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}

		/* Align for `valueType` field */
		_ALIGN(ctx->at, 8);

		/* Write `valueType` field */
		{
			const uint8_t tmp_val = (uint8_t) p_valueType;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}

		/* Align for `base` field */
		_ALIGN(ctx->at, 8);

		/* Write `base` field */
		{
			const uint8_t tmp_val = (uint8_t) p_base;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}

		/* Align for `exponent` field */
		_ALIGN(ctx->at, 64);

		/* Write `exponent` field */
		{
			const uint64_t tmp_val = (uint64_t) p_exponent;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `unit` field */
		_ALIGN(ctx->at, 32);

		/* Write `unit` field */
		{
			const uint32_t tmp_val = (uint32_t) p_unit;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_GlobalDef_Paradigm(void * const vctx,
	const uint8_t p_paradigm,
	const uint32_t p_name,
	const uint8_t p_paradigmClass)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 153);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `paradigm` field */
		_ALIGN(ctx->at, 8);

		/* Write `paradigm` field */
		{
			const uint8_t tmp_val = (uint8_t) p_paradigm;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}

		/* Align for `name` field */
		_ALIGN(ctx->at, 32);

		/* Write `name` field */
		{
			const uint32_t tmp_val = (uint32_t) p_name;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `paradigmClass` field */
		_ALIGN(ctx->at, 8);

		/* Write `paradigmClass` field */
		{
			const uint8_t tmp_val = (uint8_t) p_paradigmClass;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}
	}
}

static void _serialize_er_default_GlobalDef_ParadigmProperty(void * const vctx,
	const uint8_t p_paradigm,
	const uint8_t p_property)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 154);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 8);

		/* Align for `paradigm` field */
		_ALIGN(ctx->at, 8);

		/* Write `paradigm` field */
		{
			const uint8_t tmp_val = (uint8_t) p_paradigm;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}

		/* Align for `property` field */
		_ALIGN(ctx->at, 8);

		/* Write `property` field */
		{
			const uint8_t tmp_val = (uint8_t) p_property;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}
	}
}

static void _serialize_er_default_GlobalDef_Parameter(void * const vctx,
	const uint32_t p_self,
	const uint32_t p_name,
	const uint8_t p_parameterType)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 155);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `self` field */
		_ALIGN(ctx->at, 32);

		/* Write `self` field */
		{
			const uint32_t tmp_val = (uint32_t) p_self;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `name` field */
		_ALIGN(ctx->at, 32);

		/* Write `name` field */
		{
			const uint32_t tmp_val = (uint32_t) p_name;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `parameterType` field */
		_ALIGN(ctx->at, 8);

		/* Write `parameterType` field */
		{
			const uint8_t tmp_val = (uint8_t) p_parameterType;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}
	}
}

static void _serialize_er_default_GlobalDef_Region(void * const vctx,
	const uint32_t p_self,
	const uint32_t p_name,
	const uint32_t p_canonicalName,
	const uint32_t p_description,
	const uint8_t p_regionRole,
	const uint8_t p_paradigm,
	const uint32_t p_regionFlag,
	const uint32_t p_sourceFile,
	const uint32_t p_beginLineNumber,
	const uint32_t p_endLineNumber)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 156);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `self` field */
		_ALIGN(ctx->at, 32);

		/* Write `self` field */
		{
			const uint32_t tmp_val = (uint32_t) p_self;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `name` field */
		_ALIGN(ctx->at, 32);

		/* Write `name` field */
		{
			const uint32_t tmp_val = (uint32_t) p_name;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `canonicalName` field */
		_ALIGN(ctx->at, 32);

		/* Write `canonicalName` field */
		{
			const uint32_t tmp_val = (uint32_t) p_canonicalName;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `description` field */
		_ALIGN(ctx->at, 32);

		/* Write `description` field */
		{
			const uint32_t tmp_val = (uint32_t) p_description;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `regionRole` field */
		_ALIGN(ctx->at, 8);

		/* Write `regionRole` field */
		{
			const uint8_t tmp_val = (uint8_t) p_regionRole;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}

		/* Align for `paradigm` field */
		_ALIGN(ctx->at, 8);

		/* Write `paradigm` field */
		{
			const uint8_t tmp_val = (uint8_t) p_paradigm;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}

		/* Align for `regionFlag` field */
		_ALIGN(ctx->at, 32);

		/* Write `regionFlag` field */
		{
			const uint32_t tmp_val = (uint32_t) p_regionFlag;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `sourceFile` field */
		_ALIGN(ctx->at, 32);

		/* Write `sourceFile` field */
		{
			const uint32_t tmp_val = (uint32_t) p_sourceFile;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `beginLineNumber` field */
		_ALIGN(ctx->at, 32);

		/* Write `beginLineNumber` field */
		{
			const uint32_t tmp_val = (uint32_t) p_beginLineNumber;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `endLineNumber` field */
		_ALIGN(ctx->at, 32);

		/* Write `endLineNumber` field */
		{
			const uint32_t tmp_val = (uint32_t) p_endLineNumber;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_GlobalDef_RmaWin(void * const vctx,
	const uint32_t p_self,
	const uint32_t p_name,
	const uint32_t p_comm)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 157);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `self` field */
		_ALIGN(ctx->at, 32);

		/* Write `self` field */
		{
			const uint32_t tmp_val = (uint32_t) p_self;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `name` field */
		_ALIGN(ctx->at, 32);

		/* Write `name` field */
		{
			const uint32_t tmp_val = (uint32_t) p_name;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `comm` field */
		_ALIGN(ctx->at, 32);

		/* Write `comm` field */
		{
			const uint32_t tmp_val = (uint32_t) p_comm;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_GlobalDef_SourceCodeLocation(void * const vctx,
	const uint32_t p_self,
	const uint32_t p_file,
	const uint32_t p_lineNumber)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 158);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `self` field */
		_ALIGN(ctx->at, 32);

		/* Write `self` field */
		{
			const uint32_t tmp_val = (uint32_t) p_self;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `file` field */
		_ALIGN(ctx->at, 32);

		/* Write `file` field */
		{
			const uint32_t tmp_val = (uint32_t) p_file;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `lineNumber` field */
		_ALIGN(ctx->at, 32);

		/* Write `lineNumber` field */
		{
			const uint32_t tmp_val = (uint32_t) p_lineNumber;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_GlobalDef_String(void * const vctx,
	const uint32_t p_self,
	const char * const p_stringValue)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 159);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `self` field */
		_ALIGN(ctx->at, 32);

		/* Write `self` field */
		{
			const uint32_t tmp_val = (uint32_t) p_self;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `stringValue` field */
		_ALIGN(ctx->at, 8);

		/* Write `stringValue` field */
		_write_c_str(ctx, p_stringValue);
	}
}

static void _serialize_er_default_GlobalDef_SystemTreeNode(void * const vctx,
	const uint32_t p_self,
	const uint32_t p_name,
	const uint32_t p_className,
	const uint32_t p_systemTreeParent)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 160);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `self` field */
		_ALIGN(ctx->at, 32);

		/* Write `self` field */
		{
			const uint32_t tmp_val = (uint32_t) p_self;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `name` field */
		_ALIGN(ctx->at, 32);

		/* Write `name` field */
		{
			const uint32_t tmp_val = (uint32_t) p_name;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `className` field */
		_ALIGN(ctx->at, 32);

		/* Write `className` field */
		{
			const uint32_t tmp_val = (uint32_t) p_className;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `systemTreeParent` field */
		_ALIGN(ctx->at, 32);

		/* Write `systemTreeParent` field */
		{
			const uint32_t tmp_val = (uint32_t) p_systemTreeParent;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_GlobalDef_SystemTreeNodeDomain(void * const vctx,
	const uint32_t p_systemTreeNode,
	const uint8_t p_systemTreeDomain)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 161);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `systemTreeNode` field */
		_ALIGN(ctx->at, 32);

		/* Write `systemTreeNode` field */
		{
			const uint32_t tmp_val = (uint32_t) p_systemTreeNode;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `systemTreeDomain` field */
		_ALIGN(ctx->at, 8);

		/* Write `systemTreeDomain` field */
		{
			const uint8_t tmp_val = (uint8_t) p_systemTreeDomain;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 8;
		}
	}
}

static void _serialize_er_default_GlobalDef_SystemTreeNodeProperty(void * const vctx,
	const uint32_t p_systemTreeNode,
	const uint32_t p_name)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 162);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `systemTreeNode` field */
		_ALIGN(ctx->at, 32);

		/* Write `systemTreeNode` field */
		{
			const uint32_t tmp_val = (uint32_t) p_systemTreeNode;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `name` field */
		_ALIGN(ctx->at, 32);

		/* Write `name` field */
		{
			const uint32_t tmp_val = (uint32_t) p_name;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}
	}
}

static void _serialize_er_default_MetricValue_Double(void * const vctx,
	const double p_metricValue)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 163);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `metricValue` field */
		_ALIGN(ctx->at, 64);

		/* Write `metricValue` field */
		{
			union _d2u d2u;

			d2u.f = p_metricValue;
			{
				const uint64_t tmp_val = (uint64_t) d2u.u;

				memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
				ctx->at += 64;
			}
		}
	}
}

static void _serialize_er_default_MetricValue_Int64(void * const vctx,
	const int64_t p_metricValue)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 164);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `metricValue` field */
		_ALIGN(ctx->at, 64);

		/* Write `metricValue` field */
		{
			const uint64_t tmp_val = (uint64_t) p_metricValue;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_MetricValue_UInt64(void * const vctx,
	const uint64_t p_metricValue)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 165);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `metricValue` field */
		_ALIGN(ctx->at, 64);

		/* Write `metricValue` field */
		{
			const uint64_t tmp_val = (uint64_t) p_metricValue;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static uint32_t _er_size_default_EventAttribute_Attribute(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `attribute` field */
		_ALIGN(at, 32);

		/* Add `attribute` bit array field's size */
		at += 32;

		/* Align for `value` field */
		_ALIGN(at, 32);

		/* Add `value` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_EventAttribute_CallingContext(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `attribute` field */
		_ALIGN(at, 32);

		/* Add `attribute` bit array field's size */
		at += 32;

		/* Align for `value` field */
		_ALIGN(at, 32);

		/* Add `value` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_EventAttribute_Comm(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `attribute` field */
		_ALIGN(at, 32);

		/* Add `attribute` bit array field's size */
		at += 32;

		/* Align for `value` field */
		_ALIGN(at, 32);

		/* Add `value` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_EventAttribute_Double(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `attribute` field */
		_ALIGN(at, 32);

		/* Add `attribute` bit array field's size */
		at += 32;

		/* Align for `value` field */
		_ALIGN(at, 64);

		/* Add `value` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_EventAttribute_Float(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `attribute` field */
		_ALIGN(at, 32);

		/* Add `attribute` bit array field's size */
		at += 32;

		/* Align for `value` field */
		_ALIGN(at, 32);

		/* Add `value` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_EventAttribute_Group(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `attribute` field */
		_ALIGN(at, 32);

		/* Add `attribute` bit array field's size */
		at += 32;

		/* Align for `value` field */
		_ALIGN(at, 32);

		/* Add `value` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_EventAttribute_Int16(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `attribute` field */
		_ALIGN(at, 32);

		/* Add `attribute` bit array field's size */
		at += 32;

		/* Align for `value` field */
		_ALIGN(at, 16);

		/* Add `value` bit array field's size */
		at += 16;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_EventAttribute_Int32(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `attribute` field */
		_ALIGN(at, 32);

		/* Add `attribute` bit array field's size */
		at += 32;

		/* Align for `value` field */
		_ALIGN(at, 32);

		/* Add `value` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_EventAttribute_Int64(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `attribute` field */
		_ALIGN(at, 32);

		/* Add `attribute` bit array field's size */
		at += 32;

		/* Align for `value` field */
		_ALIGN(at, 64);

		/* Add `value` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_EventAttribute_Int8(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `attribute` field */
		_ALIGN(at, 32);

		/* Add `attribute` bit array field's size */
		at += 32;

		/* Align for `value` field */
		_ALIGN(at, 8);

		/* Add `value` bit array field's size */
		at += 8;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_EventAttribute_InterruptGenerator(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `attribute` field */
		_ALIGN(at, 32);

		/* Add `attribute` bit array field's size */
		at += 32;

		/* Align for `value` field */
		_ALIGN(at, 32);

		/* Add `value` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_EventAttribute_IoFile(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `attribute` field */
		_ALIGN(at, 32);

		/* Add `attribute` bit array field's size */
		at += 32;

		/* Align for `value` field */
		_ALIGN(at, 32);

		/* Add `value` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_EventAttribute_IoHandle(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `attribute` field */
		_ALIGN(at, 32);

		/* Add `attribute` bit array field's size */
		at += 32;

		/* Align for `value` field */
		_ALIGN(at, 32);

		/* Add `value` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_EventAttribute_Location(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `attribute` field */
		_ALIGN(at, 32);

		/* Add `attribute` bit array field's size */
		at += 32;

		/* Align for `value` field */
		_ALIGN(at, 64);

		/* Add `value` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_EventAttribute_Metric(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `attribute` field */
		_ALIGN(at, 32);

		/* Add `attribute` bit array field's size */
		at += 32;

		/* Align for `value` field */
		_ALIGN(at, 32);

		/* Add `value` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_EventAttribute_Parameter(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `attribute` field */
		_ALIGN(at, 32);

		/* Add `attribute` bit array field's size */
		at += 32;

		/* Align for `value` field */
		_ALIGN(at, 32);

		/* Add `value` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_EventAttribute_Region(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `attribute` field */
		_ALIGN(at, 32);

		/* Add `attribute` bit array field's size */
		at += 32;

		/* Align for `value` field */
		_ALIGN(at, 32);

		/* Add `value` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_EventAttribute_RmaWin(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `attribute` field */
		_ALIGN(at, 32);

		/* Add `attribute` bit array field's size */
		at += 32;

		/* Align for `value` field */
		_ALIGN(at, 32);

		/* Add `value` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_EventAttribute_SourceCodeLocation(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `attribute` field */
		_ALIGN(at, 32);

		/* Add `attribute` bit array field's size */
		at += 32;

		/* Align for `value` field */
		_ALIGN(at, 32);

		/* Add `value` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_EventAttribute_String(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `attribute` field */
		_ALIGN(at, 32);

		/* Add `attribute` bit array field's size */
		at += 32;

		/* Align for `value` field */
		_ALIGN(at, 32);

		/* Add `value` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_EventAttribute_UInt16(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `attribute` field */
		_ALIGN(at, 32);

		/* Add `attribute` bit array field's size */
		at += 32;

		/* Align for `value` field */
		_ALIGN(at, 16);

		/* Add `value` bit array field's size */
		at += 16;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_EventAttribute_UInt32(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `attribute` field */
		_ALIGN(at, 32);

		/* Add `attribute` bit array field's size */
		at += 32;

		/* Align for `value` field */
		_ALIGN(at, 32);

		/* Add `value` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_EventAttribute_UInt64(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `attribute` field */
		_ALIGN(at, 32);

		/* Add `attribute` bit array field's size */
		at += 32;

		/* Align for `value` field */
		_ALIGN(at, 64);

		/* Add `value` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_EventAttribute_UInt8(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `attribute` field */
		_ALIGN(at, 32);

		/* Add `attribute` bit array field's size */
		at += 32;

		/* Align for `value` field */
		_ALIGN(at, 8);

		/* Add `value` bit array field's size */
		at += 8;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_BufferFlush(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `stopTime` field */
		_ALIGN(at, 64);

		/* Add `stopTime` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_CallingContextEnter(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `callingContext` field */
		_ALIGN(at, 32);

		/* Add `callingContext` bit array field's size */
		at += 32;

		/* Align for `unwindDistance` field */
		_ALIGN(at, 32);

		/* Add `unwindDistance` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_CallingContextLeave(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `callingContext` field */
		_ALIGN(at, 32);

		/* Add `callingContext` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_CallingContextSample(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `callingContext` field */
		_ALIGN(at, 32);

		/* Add `callingContext` bit array field's size */
		at += 32;

		/* Align for `unwindDistance` field */
		_ALIGN(at, 32);

		/* Add `unwindDistance` bit array field's size */
		at += 32;

		/* Align for `interruptGenerator` field */
		_ALIGN(at, 32);

		/* Add `interruptGenerator` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_Enter(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `region` field */
		_ALIGN(at, 32);

		/* Add `region` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_IoAcquireLock(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `handle` field */
		_ALIGN(at, 32);

		/* Add `handle` bit array field's size */
		at += 32;

		/* Align for `lockType` field */
		_ALIGN(at, 8);

		/* Add `lockType` bit array field's size */
		at += 8;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_IoChangeStatusFlags(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `handle` field */
		_ALIGN(at, 32);

		/* Add `handle` bit array field's size */
		at += 32;

		/* Align for `statusFlags` field */
		_ALIGN(at, 32);

		/* Add `statusFlags` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_IoCreateHandle(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `handle` field */
		_ALIGN(at, 32);

		/* Add `handle` bit array field's size */
		at += 32;

		/* Align for `mode` field */
		_ALIGN(at, 8);

		/* Add `mode` bit array field's size */
		at += 8;

		/* Align for `creationFlags` field */
		_ALIGN(at, 32);

		/* Add `creationFlags` bit array field's size */
		at += 32;

		/* Align for `statusFlags` field */
		_ALIGN(at, 32);

		/* Add `statusFlags` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_IoDeleteFile(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `ioParadigm` field */
		_ALIGN(at, 8);

		/* Add `ioParadigm` bit array field's size */
		at += 8;

		/* Align for `file` field */
		_ALIGN(at, 32);

		/* Add `file` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_IoDestroyHandle(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `handle` field */
		_ALIGN(at, 32);

		/* Add `handle` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_IoDuplicateHandle(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `oldHandle` field */
		_ALIGN(at, 32);

		/* Add `oldHandle` bit array field's size */
		at += 32;

		/* Align for `newHandle` field */
		_ALIGN(at, 32);

		/* Add `newHandle` bit array field's size */
		at += 32;

		/* Align for `statusFlags` field */
		_ALIGN(at, 32);

		/* Add `statusFlags` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_IoOperationBegin(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `handle` field */
		_ALIGN(at, 32);

		/* Add `handle` bit array field's size */
		at += 32;

		/* Align for `mode` field */
		_ALIGN(at, 8);

		/* Add `mode` bit array field's size */
		at += 8;

		/* Align for `operationFlags` field */
		_ALIGN(at, 32);

		/* Add `operationFlags` bit array field's size */
		at += 32;

		/* Align for `bytesRequest` field */
		_ALIGN(at, 64);

		/* Add `bytesRequest` bit array field's size */
		at += 64;

		/* Align for `matchingId` field */
		_ALIGN(at, 64);

		/* Add `matchingId` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_IoOperationCancelled(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `handle` field */
		_ALIGN(at, 32);

		/* Add `handle` bit array field's size */
		at += 32;

		/* Align for `matchingId` field */
		_ALIGN(at, 64);

		/* Add `matchingId` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_IoOperationComplete(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `handle` field */
		_ALIGN(at, 32);

		/* Add `handle` bit array field's size */
		at += 32;

		/* Align for `bytesResult` field */
		_ALIGN(at, 64);

		/* Add `bytesResult` bit array field's size */
		at += 64;

		/* Align for `matchingId` field */
		_ALIGN(at, 64);

		/* Add `matchingId` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_IoOperationIssued(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `handle` field */
		_ALIGN(at, 32);

		/* Add `handle` bit array field's size */
		at += 32;

		/* Align for `matchingId` field */
		_ALIGN(at, 64);

		/* Add `matchingId` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_IoOperationTest(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `handle` field */
		_ALIGN(at, 32);

		/* Add `handle` bit array field's size */
		at += 32;

		/* Align for `matchingId` field */
		_ALIGN(at, 64);

		/* Add `matchingId` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_IoReleaseLock(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `handle` field */
		_ALIGN(at, 32);

		/* Add `handle` bit array field's size */
		at += 32;

		/* Align for `lockType` field */
		_ALIGN(at, 8);

		/* Add `lockType` bit array field's size */
		at += 8;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_IoSeek(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `handle` field */
		_ALIGN(at, 32);

		/* Add `handle` bit array field's size */
		at += 32;

		/* Align for `offsetRequest` field */
		_ALIGN(at, 64);

		/* Add `offsetRequest` bit array field's size */
		at += 64;

		/* Align for `whence` field */
		_ALIGN(at, 8);

		/* Add `whence` bit array field's size */
		at += 8;

		/* Align for `offsetResult` field */
		_ALIGN(at, 64);

		/* Add `offsetResult` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_IoTryLock(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `handle` field */
		_ALIGN(at, 32);

		/* Add `handle` bit array field's size */
		at += 32;

		/* Align for `lockType` field */
		_ALIGN(at, 8);

		/* Add `lockType` bit array field's size */
		at += 8;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_Leave(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `region` field */
		_ALIGN(at, 32);

		/* Add `region` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_MeasurementOnOff(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `measurementMode` field */
		_ALIGN(at, 8);

		/* Add `measurementMode` bit array field's size */
		at += 8;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_Metric(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `metric` field */
		_ALIGN(at, 32);

		/* Add `metric` bit array field's size */
		at += 32;

		/* Align for `numberOfMetrics` field */
		_ALIGN(at, 8);

		/* Add `numberOfMetrics` bit array field's size */
		at += 8;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_MpiCollectiveBegin(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_MpiCollectiveEnd(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `collectiveOp` field */
		_ALIGN(at, 8);

		/* Add `collectiveOp` bit array field's size */
		at += 8;

		/* Align for `communicator` field */
		_ALIGN(at, 32);

		/* Add `communicator` bit array field's size */
		at += 32;

		/* Align for `root` field */
		_ALIGN(at, 32);

		/* Add `root` bit array field's size */
		at += 32;

		/* Align for `sizeSent` field */
		_ALIGN(at, 64);

		/* Add `sizeSent` bit array field's size */
		at += 64;

		/* Align for `sizeReceived` field */
		_ALIGN(at, 64);

		/* Add `sizeReceived` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_MpiIrecv(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `receiver` field */
		_ALIGN(at, 32);

		/* Add `receiver` bit array field's size */
		at += 32;

		/* Align for `communicator` field */
		_ALIGN(at, 32);

		/* Add `communicator` bit array field's size */
		at += 32;

		/* Align for `msgTag` field */
		_ALIGN(at, 32);

		/* Add `msgTag` bit array field's size */
		at += 32;

		/* Align for `msgLength` field */
		_ALIGN(at, 64);

		/* Add `msgLength` bit array field's size */
		at += 64;

		/* Align for `requestID` field */
		_ALIGN(at, 64);

		/* Add `requestID` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_MpiIrecvRequest(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `requestID` field */
		_ALIGN(at, 64);

		/* Add `requestID` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_MpiIsend(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `receiver` field */
		_ALIGN(at, 32);

		/* Add `receiver` bit array field's size */
		at += 32;

		/* Align for `communicator` field */
		_ALIGN(at, 32);

		/* Add `communicator` bit array field's size */
		at += 32;

		/* Align for `msgTag` field */
		_ALIGN(at, 32);

		/* Add `msgTag` bit array field's size */
		at += 32;

		/* Align for `msgLength` field */
		_ALIGN(at, 64);

		/* Add `msgLength` bit array field's size */
		at += 64;

		/* Align for `requestID` field */
		_ALIGN(at, 64);

		/* Add `requestID` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_MpiIsendComplete(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `requestID` field */
		_ALIGN(at, 64);

		/* Add `requestID` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_MpiRecv(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `sender` field */
		_ALIGN(at, 32);

		/* Add `sender` bit array field's size */
		at += 32;

		/* Align for `communicator` field */
		_ALIGN(at, 32);

		/* Add `communicator` bit array field's size */
		at += 32;

		/* Align for `msgTag` field */
		_ALIGN(at, 32);

		/* Add `msgTag` bit array field's size */
		at += 32;

		/* Align for `msgLength` field */
		_ALIGN(at, 64);

		/* Add `msgLength` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_MpiRequestCancelled(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `requestID` field */
		_ALIGN(at, 64);

		/* Add `requestID` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_MpiRequestTest(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `requestID` field */
		_ALIGN(at, 64);

		/* Add `requestID` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_MpiSend(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `receiver` field */
		_ALIGN(at, 32);

		/* Add `receiver` bit array field's size */
		at += 32;

		/* Align for `communicator` field */
		_ALIGN(at, 32);

		/* Add `communicator` bit array field's size */
		at += 32;

		/* Align for `msgTag` field */
		_ALIGN(at, 32);

		/* Add `msgTag` bit array field's size */
		at += 32;

		/* Align for `msgLength` field */
		_ALIGN(at, 64);

		/* Add `msgLength` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_OmpAcquireLock(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `lockID` field */
		_ALIGN(at, 32);

		/* Add `lockID` bit array field's size */
		at += 32;

		/* Align for `acquisitionOrder` field */
		_ALIGN(at, 32);

		/* Add `acquisitionOrder` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_OmpFork(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `numberOfRequestedThreads` field */
		_ALIGN(at, 32);

		/* Add `numberOfRequestedThreads` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_OmpJoin(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_OmpReleaseLock(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `lockID` field */
		_ALIGN(at, 32);

		/* Add `lockID` bit array field's size */
		at += 32;

		/* Align for `acquisitionOrder` field */
		_ALIGN(at, 32);

		/* Add `acquisitionOrder` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_OmpTaskComplete(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `taskID` field */
		_ALIGN(at, 64);

		/* Add `taskID` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_OmpTaskCreate(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `taskID` field */
		_ALIGN(at, 64);

		/* Add `taskID` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_OmpTaskSwitch(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `taskID` field */
		_ALIGN(at, 64);

		/* Add `taskID` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_ParameterInt(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `parameter` field */
		_ALIGN(at, 32);

		/* Add `parameter` bit array field's size */
		at += 32;

		/* Align for `value` field */
		_ALIGN(at, 64);

		/* Add `value` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_ParameterString(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `parameter` field */
		_ALIGN(at, 32);

		/* Add `parameter` bit array field's size */
		at += 32;

		/* Align for `stringID` field */
		_ALIGN(at, 32);

		/* Add `stringID` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_ParameterUnsignedInt(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `parameter` field */
		_ALIGN(at, 32);

		/* Add `parameter` bit array field's size */
		at += 32;

		/* Align for `value` field */
		_ALIGN(at, 64);

		/* Add `value` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_ProgramArgument(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `programArgument` field */
		_ALIGN(at, 32);

		/* Add `programArgument` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_ProgramBegin(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `programName` field */
		_ALIGN(at, 32);

		/* Add `programName` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_ProgramEnd(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `exitStatus` field */
		_ALIGN(at, 64);

		/* Add `exitStatus` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_RmaAcquireLock(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `win` field */
		_ALIGN(at, 32);

		/* Add `win` bit array field's size */
		at += 32;

		/* Align for `remote` field */
		_ALIGN(at, 32);

		/* Add `remote` bit array field's size */
		at += 32;

		/* Align for `lockId` field */
		_ALIGN(at, 64);

		/* Add `lockId` bit array field's size */
		at += 64;

		/* Align for `lockType` field */
		_ALIGN(at, 8);

		/* Add `lockType` bit array field's size */
		at += 8;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_RmaAtomic(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `win` field */
		_ALIGN(at, 32);

		/* Add `win` bit array field's size */
		at += 32;

		/* Align for `remote` field */
		_ALIGN(at, 32);

		/* Add `remote` bit array field's size */
		at += 32;

		/* Align for `type` field */
		_ALIGN(at, 8);

		/* Add `type` bit array field's size */
		at += 8;

		/* Align for `bytesSent` field */
		_ALIGN(at, 64);

		/* Add `bytesSent` bit array field's size */
		at += 64;

		/* Align for `bytesReceived` field */
		_ALIGN(at, 64);

		/* Add `bytesReceived` bit array field's size */
		at += 64;

		/* Align for `matchingId` field */
		_ALIGN(at, 64);

		/* Add `matchingId` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_RmaCollectiveBegin(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_RmaCollectiveEnd(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `collectiveOp` field */
		_ALIGN(at, 8);

		/* Add `collectiveOp` bit array field's size */
		at += 8;

		/* Align for `syncLevel` field */
		_ALIGN(at, 32);

		/* Add `syncLevel` bit array field's size */
		at += 32;

		/* Align for `win` field */
		_ALIGN(at, 32);

		/* Add `win` bit array field's size */
		at += 32;

		/* Align for `root` field */
		_ALIGN(at, 32);

		/* Add `root` bit array field's size */
		at += 32;

		/* Align for `bytesSent` field */
		_ALIGN(at, 64);

		/* Add `bytesSent` bit array field's size */
		at += 64;

		/* Align for `bytesReceived` field */
		_ALIGN(at, 64);

		/* Add `bytesReceived` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_RmaGet(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `win` field */
		_ALIGN(at, 32);

		/* Add `win` bit array field's size */
		at += 32;

		/* Align for `remote` field */
		_ALIGN(at, 32);

		/* Add `remote` bit array field's size */
		at += 32;

		/* Align for `bytes` field */
		_ALIGN(at, 64);

		/* Add `bytes` bit array field's size */
		at += 64;

		/* Align for `matchingId` field */
		_ALIGN(at, 64);

		/* Add `matchingId` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_RmaGroupSync(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `syncLevel` field */
		_ALIGN(at, 32);

		/* Add `syncLevel` bit array field's size */
		at += 32;

		/* Align for `win` field */
		_ALIGN(at, 32);

		/* Add `win` bit array field's size */
		at += 32;

		/* Align for `group` field */
		_ALIGN(at, 32);

		/* Add `group` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_RmaOpCompleteBlocking(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `win` field */
		_ALIGN(at, 32);

		/* Add `win` bit array field's size */
		at += 32;

		/* Align for `matchingId` field */
		_ALIGN(at, 64);

		/* Add `matchingId` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_RmaOpCompleteNonBlocking(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `win` field */
		_ALIGN(at, 32);

		/* Add `win` bit array field's size */
		at += 32;

		/* Align for `matchingId` field */
		_ALIGN(at, 64);

		/* Add `matchingId` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_RmaOpCompleteRemote(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `win` field */
		_ALIGN(at, 32);

		/* Add `win` bit array field's size */
		at += 32;

		/* Align for `matchingId` field */
		_ALIGN(at, 64);

		/* Add `matchingId` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_RmaOpTest(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `win` field */
		_ALIGN(at, 32);

		/* Add `win` bit array field's size */
		at += 32;

		/* Align for `matchingId` field */
		_ALIGN(at, 64);

		/* Add `matchingId` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_RmaPut(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `win` field */
		_ALIGN(at, 32);

		/* Add `win` bit array field's size */
		at += 32;

		/* Align for `remote` field */
		_ALIGN(at, 32);

		/* Add `remote` bit array field's size */
		at += 32;

		/* Align for `bytes` field */
		_ALIGN(at, 64);

		/* Add `bytes` bit array field's size */
		at += 64;

		/* Align for `matchingId` field */
		_ALIGN(at, 64);

		/* Add `matchingId` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_RmaReleaseLock(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `win` field */
		_ALIGN(at, 32);

		/* Add `win` bit array field's size */
		at += 32;

		/* Align for `remote` field */
		_ALIGN(at, 32);

		/* Add `remote` bit array field's size */
		at += 32;

		/* Align for `lockId` field */
		_ALIGN(at, 64);

		/* Add `lockId` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_RmaRequestLock(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `win` field */
		_ALIGN(at, 32);

		/* Add `win` bit array field's size */
		at += 32;

		/* Align for `remote` field */
		_ALIGN(at, 32);

		/* Add `remote` bit array field's size */
		at += 32;

		/* Align for `lockId` field */
		_ALIGN(at, 64);

		/* Add `lockId` bit array field's size */
		at += 64;

		/* Align for `lockType` field */
		_ALIGN(at, 8);

		/* Add `lockType` bit array field's size */
		at += 8;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_RmaSync(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `win` field */
		_ALIGN(at, 32);

		/* Add `win` bit array field's size */
		at += 32;

		/* Align for `remote` field */
		_ALIGN(at, 32);

		/* Add `remote` bit array field's size */
		at += 32;

		/* Align for `syncType` field */
		_ALIGN(at, 8);

		/* Add `syncType` bit array field's size */
		at += 8;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_RmaTryLock(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `win` field */
		_ALIGN(at, 32);

		/* Add `win` bit array field's size */
		at += 32;

		/* Align for `remote` field */
		_ALIGN(at, 32);

		/* Add `remote` bit array field's size */
		at += 32;

		/* Align for `lockId` field */
		_ALIGN(at, 64);

		/* Add `lockId` bit array field's size */
		at += 64;

		/* Align for `lockType` field */
		_ALIGN(at, 8);

		/* Add `lockType` bit array field's size */
		at += 8;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_RmaWaitChange(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `win` field */
		_ALIGN(at, 32);

		/* Add `win` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_RmaWinCreate(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `win` field */
		_ALIGN(at, 32);

		/* Add `win` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_RmaWinDestroy(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `win` field */
		_ALIGN(at, 32);

		/* Add `win` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_ThreadAcquireLock(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `model` field */
		_ALIGN(at, 8);

		/* Add `model` bit array field's size */
		at += 8;

		/* Align for `lockID` field */
		_ALIGN(at, 32);

		/* Add `lockID` bit array field's size */
		at += 32;

		/* Align for `acquisitionOrder` field */
		_ALIGN(at, 32);

		/* Add `acquisitionOrder` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_ThreadBegin(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `threadContingent` field */
		_ALIGN(at, 32);

		/* Add `threadContingent` bit array field's size */
		at += 32;

		/* Align for `sequenceCount` field */
		_ALIGN(at, 64);

		/* Add `sequenceCount` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_ThreadCreate(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `threadContingent` field */
		_ALIGN(at, 32);

		/* Add `threadContingent` bit array field's size */
		at += 32;

		/* Align for `sequenceCount` field */
		_ALIGN(at, 64);

		/* Add `sequenceCount` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_ThreadEnd(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `threadContingent` field */
		_ALIGN(at, 32);

		/* Add `threadContingent` bit array field's size */
		at += 32;

		/* Align for `sequenceCount` field */
		_ALIGN(at, 64);

		/* Add `sequenceCount` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_ThreadFork(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `model` field */
		_ALIGN(at, 8);

		/* Add `model` bit array field's size */
		at += 8;

		/* Align for `matchnumberOfRequestedThreadsingId` field */
		_ALIGN(at, 32);

		/* Add `matchnumberOfRequestedThreadsingId` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_ThreadJoin(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `model` field */
		_ALIGN(at, 8);

		/* Add `model` bit array field's size */
		at += 8;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_ThreadReleaseLock(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `model` field */
		_ALIGN(at, 8);

		/* Add `model` bit array field's size */
		at += 8;

		/* Align for `lockID` field */
		_ALIGN(at, 32);

		/* Add `lockID` bit array field's size */
		at += 32;

		/* Align for `acquisitionOrder` field */
		_ALIGN(at, 32);

		/* Add `acquisitionOrder` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_ThreadTaskComplete(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `threadTeam` field */
		_ALIGN(at, 32);

		/* Add `threadTeam` bit array field's size */
		at += 32;

		/* Align for `creatingThread` field */
		_ALIGN(at, 32);

		/* Add `creatingThread` bit array field's size */
		at += 32;

		/* Align for `generationNumber` field */
		_ALIGN(at, 32);

		/* Add `generationNumber` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_ThreadTaskCreate(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `threadTeam` field */
		_ALIGN(at, 32);

		/* Add `threadTeam` bit array field's size */
		at += 32;

		/* Align for `creatingThread` field */
		_ALIGN(at, 32);

		/* Add `creatingThread` bit array field's size */
		at += 32;

		/* Align for `generationNumber` field */
		_ALIGN(at, 32);

		/* Add `generationNumber` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_ThreadTaskSwitch(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `threadTeam` field */
		_ALIGN(at, 32);

		/* Add `threadTeam` bit array field's size */
		at += 32;

		/* Align for `creatingThread` field */
		_ALIGN(at, 32);

		/* Add `creatingThread` bit array field's size */
		at += 32;

		/* Align for `generationNumber` field */
		_ALIGN(at, 32);

		/* Add `generationNumber` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_ThreadTeamBegin(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `threadTeam` field */
		_ALIGN(at, 32);

		/* Add `threadTeam` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_ThreadTeamEnd(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `threadTeam` field */
		_ALIGN(at, 32);

		/* Add `threadTeam` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_Event_ThreadWait(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `locationID` field */
		_ALIGN(at, 64);

		/* Add `locationID` bit array field's size */
		at += 64;

		/* Align for `threadContingent` field */
		_ALIGN(at, 32);

		/* Add `threadContingent` bit array field's size */
		at += 32;

		/* Align for `sequenceCount` field */
		_ALIGN(at, 64);

		/* Add `sequenceCount` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDefAttribute_Attribute(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `value` field */
		_ALIGN(at, 32);

		/* Add `value` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDefAttribute_CallingContext(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `value` field */
		_ALIGN(at, 32);

		/* Add `value` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDefAttribute_Comm(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `value` field */
		_ALIGN(at, 32);

		/* Add `value` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDefAttribute_Double(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `value` field */
		_ALIGN(at, 64);

		/* Add `value` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDefAttribute_Float(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `value` field */
		_ALIGN(at, 32);

		/* Add `value` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDefAttribute_Group(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `value` field */
		_ALIGN(at, 32);

		/* Add `value` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDefAttribute_Int16(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 16);

		/* Align for `value` field */
		_ALIGN(at, 16);

		/* Add `value` bit array field's size */
		at += 16;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDefAttribute_Int32(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `value` field */
		_ALIGN(at, 32);

		/* Add `value` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDefAttribute_Int64(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `value` field */
		_ALIGN(at, 64);

		/* Add `value` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDefAttribute_Int8(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 8);

		/* Align for `value` field */
		_ALIGN(at, 8);

		/* Add `value` bit array field's size */
		at += 8;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDefAttribute_InterruptGenerator(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `value` field */
		_ALIGN(at, 32);

		/* Add `value` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDefAttribute_IoFile(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `value` field */
		_ALIGN(at, 32);

		/* Add `value` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDefAttribute_IoHandle(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `value` field */
		_ALIGN(at, 32);

		/* Add `value` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDefAttribute_Location(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `value` field */
		_ALIGN(at, 64);

		/* Add `value` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDefAttribute_Metric(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `value` field */
		_ALIGN(at, 32);

		/* Add `value` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDefAttribute_Parameter(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `value` field */
		_ALIGN(at, 32);

		/* Add `value` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDefAttribute_Region(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `value` field */
		_ALIGN(at, 32);

		/* Add `value` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDefAttribute_RmaWin(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `value` field */
		_ALIGN(at, 32);

		/* Add `value` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDefAttribute_SourceCodeLocation(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `value` field */
		_ALIGN(at, 32);

		/* Add `value` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDefAttribute_String(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `value` field */
		_ALIGN(at, 32);

		/* Add `value` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDefAttribute_UInt16(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 16);

		/* Align for `value` field */
		_ALIGN(at, 16);

		/* Add `value` bit array field's size */
		at += 16;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDefAttribute_UInt32(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `value` field */
		_ALIGN(at, 32);

		/* Add `value` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDefAttribute_UInt64(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `value` field */
		_ALIGN(at, 64);

		/* Add `value` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDefAttribute_UInt8(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 8);

		/* Align for `value` field */
		_ALIGN(at, 8);

		/* Add `value` bit array field's size */
		at += 8;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_Attribute(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `self` field */
		_ALIGN(at, 32);

		/* Add `self` bit array field's size */
		at += 32;

		/* Align for `name` field */
		_ALIGN(at, 32);

		/* Add `name` bit array field's size */
		at += 32;

		/* Align for `description` field */
		_ALIGN(at, 32);

		/* Add `description` bit array field's size */
		at += 32;

		/* Align for `type` field */
		_ALIGN(at, 8);

		/* Add `type` bit array field's size */
		at += 8;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_CallingContext(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `self` field */
		_ALIGN(at, 32);

		/* Add `self` bit array field's size */
		at += 32;

		/* Align for `region` field */
		_ALIGN(at, 32);

		/* Add `region` bit array field's size */
		at += 32;

		/* Align for `sourceCodeLocation` field */
		_ALIGN(at, 32);

		/* Add `sourceCodeLocation` bit array field's size */
		at += 32;

		/* Align for `parent` field */
		_ALIGN(at, 32);

		/* Add `parent` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_CallingContextProperty(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `callingContext` field */
		_ALIGN(at, 32);

		/* Add `callingContext` bit array field's size */
		at += 32;

		/* Align for `name` field */
		_ALIGN(at, 32);

		/* Add `name` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_Callpath(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `self` field */
		_ALIGN(at, 32);

		/* Add `self` bit array field's size */
		at += 32;

		/* Align for `parent` field */
		_ALIGN(at, 32);

		/* Add `parent` bit array field's size */
		at += 32;

		/* Align for `region` field */
		_ALIGN(at, 32);

		/* Add `region` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_CallpathParameter(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `callpath` field */
		_ALIGN(at, 32);

		/* Add `callpath` bit array field's size */
		at += 32;

		/* Align for `parameter` field */
		_ALIGN(at, 32);

		/* Add `parameter` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_Callsite(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `self` field */
		_ALIGN(at, 32);

		/* Add `self` bit array field's size */
		at += 32;

		/* Align for `sourceFile` field */
		_ALIGN(at, 32);

		/* Add `sourceFile` bit array field's size */
		at += 32;

		/* Align for `lineNumber` field */
		_ALIGN(at, 32);

		/* Add `lineNumber` bit array field's size */
		at += 32;

		/* Align for `enteredRegion` field */
		_ALIGN(at, 32);

		/* Add `enteredRegion` bit array field's size */
		at += 32;

		/* Align for `leftRegion` field */
		_ALIGN(at, 32);

		/* Add `leftRegion` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_CartCoordinate(void * const vctx,
	const uint32_t p___coordinates_len,
	const uint32_t * const p_coordinates)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `cartTopology` field */
		_ALIGN(at, 32);

		/* Add `cartTopology` bit array field's size */
		at += 32;

		/* Align for `rank` field */
		_ALIGN(at, 32);

		/* Add `rank` bit array field's size */
		at += 32;

		/* Align for `__coordinates_len` field */
		_ALIGN(at, 8);

		/* Add `__coordinates_len` bit array field's size */
		at += 32;

		/* Align for `coordinates` field */
		_ALIGN(at, 32);

		/* Write `coordinates` field */
		{
			uint32_t i;

			for (i = 0; i < (uint32_t) p___coordinates_len; ++i) {
				/* Align for `[i]` field */
				_ALIGN(at, 32);

				/* Add `[i]` bit array field's size */
				at += 32;
			}
		}
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_CartDimension(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `self` field */
		_ALIGN(at, 32);

		/* Add `self` bit array field's size */
		at += 32;

		/* Align for `name` field */
		_ALIGN(at, 32);

		/* Add `name` bit array field's size */
		at += 32;

		/* Align for `size` field */
		_ALIGN(at, 32);

		/* Add `size` bit array field's size */
		at += 32;

		/* Align for `cartPeriodicity` field */
		_ALIGN(at, 8);

		/* Add `cartPeriodicity` bit array field's size */
		at += 8;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_CartTopology(void * const vctx,
	const uint32_t p___cartDimensions_len,
	const uint32_t * const p_cartDimensions)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `self` field */
		_ALIGN(at, 32);

		/* Add `self` bit array field's size */
		at += 32;

		/* Align for `name` field */
		_ALIGN(at, 32);

		/* Add `name` bit array field's size */
		at += 32;

		/* Align for `communicator` field */
		_ALIGN(at, 32);

		/* Add `communicator` bit array field's size */
		at += 32;

		/* Align for `__cartDimensions_len` field */
		_ALIGN(at, 8);

		/* Add `__cartDimensions_len` bit array field's size */
		at += 32;

		/* Align for `cartDimensions` field */
		_ALIGN(at, 32);

		/* Write `cartDimensions` field */
		{
			uint32_t i;

			for (i = 0; i < (uint32_t) p___cartDimensions_len; ++i) {
				/* Align for `[i]` field */
				_ALIGN(at, 32);

				/* Add `[i]` bit array field's size */
				at += 32;
			}
		}
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_ClockProperties(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `timerResolution` field */
		_ALIGN(at, 64);

		/* Add `timerResolution` bit array field's size */
		at += 64;

		/* Align for `globalOffset` field */
		_ALIGN(at, 64);

		/* Add `globalOffset` bit array field's size */
		at += 64;

		/* Align for `traceLength` field */
		_ALIGN(at, 64);

		/* Add `traceLength` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_Comm(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `self` field */
		_ALIGN(at, 32);

		/* Add `self` bit array field's size */
		at += 32;

		/* Align for `name` field */
		_ALIGN(at, 32);

		/* Add `name` bit array field's size */
		at += 32;

		/* Align for `group` field */
		_ALIGN(at, 32);

		/* Add `group` bit array field's size */
		at += 32;

		/* Align for `parent` field */
		_ALIGN(at, 32);

		/* Add `parent` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_Group(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `self` field */
		_ALIGN(at, 32);

		/* Add `self` bit array field's size */
		at += 32;

		/* Align for `name` field */
		_ALIGN(at, 32);

		/* Add `name` bit array field's size */
		at += 32;

		/* Align for `groupType` field */
		_ALIGN(at, 8);

		/* Add `groupType` bit array field's size */
		at += 8;

		/* Align for `paradigm` field */
		_ALIGN(at, 8);

		/* Add `paradigm` bit array field's size */
		at += 8;

		/* Align for `groupFlags` field */
		_ALIGN(at, 32);

		/* Add `groupFlags` bit array field's size */
		at += 32;

		/* Align for `numberOfMembers` field */
		_ALIGN(at, 32);

		/* Add `numberOfMembers` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_GroupMember(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `group` field */
		_ALIGN(at, 32);

		/* Add `group` bit array field's size */
		at += 32;

		/* Align for `rank` field */
		_ALIGN(at, 32);

		/* Add `rank` bit array field's size */
		at += 32;

		/* Align for `location` field */
		_ALIGN(at, 64);

		/* Add `location` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_InterruptGenerator(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `self` field */
		_ALIGN(at, 32);

		/* Add `self` bit array field's size */
		at += 32;

		/* Align for `name` field */
		_ALIGN(at, 32);

		/* Add `name` bit array field's size */
		at += 32;

		/* Align for `interruptGeneratorMode` field */
		_ALIGN(at, 8);

		/* Add `interruptGeneratorMode` bit array field's size */
		at += 8;

		/* Align for `base` field */
		_ALIGN(at, 8);

		/* Add `base` bit array field's size */
		at += 8;

		/* Align for `exponent` field */
		_ALIGN(at, 64);

		/* Add `exponent` bit array field's size */
		at += 64;

		/* Align for `period` field */
		_ALIGN(at, 64);

		/* Add `period` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_IoDirectory(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `self` field */
		_ALIGN(at, 32);

		/* Add `self` bit array field's size */
		at += 32;

		/* Align for `name` field */
		_ALIGN(at, 32);

		/* Add `name` bit array field's size */
		at += 32;

		/* Align for `scope` field */
		_ALIGN(at, 32);

		/* Add `scope` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_IoFileProperty(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `ioFile` field */
		_ALIGN(at, 32);

		/* Add `ioFile` bit array field's size */
		at += 32;

		/* Align for `name` field */
		_ALIGN(at, 32);

		/* Add `name` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_IoHandle(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `self` field */
		_ALIGN(at, 32);

		/* Add `self` bit array field's size */
		at += 32;

		/* Align for `name` field */
		_ALIGN(at, 32);

		/* Add `name` bit array field's size */
		at += 32;

		/* Align for `file` field */
		_ALIGN(at, 32);

		/* Add `file` bit array field's size */
		at += 32;

		/* Align for `ioParadigm` field */
		_ALIGN(at, 8);

		/* Add `ioParadigm` bit array field's size */
		at += 8;

		/* Align for `ioHandleFlags` field */
		_ALIGN(at, 32);

		/* Add `ioHandleFlags` bit array field's size */
		at += 32;

		/* Align for `comm` field */
		_ALIGN(at, 32);

		/* Add `comm` bit array field's size */
		at += 32;

		/* Align for `parent` field */
		_ALIGN(at, 32);

		/* Add `parent` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_IoParadigm(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `self` field */
		_ALIGN(at, 8);

		/* Add `self` bit array field's size */
		at += 8;

		/* Align for `identification` field */
		_ALIGN(at, 32);

		/* Add `identification` bit array field's size */
		at += 32;

		/* Align for `name` field */
		_ALIGN(at, 32);

		/* Add `name` bit array field's size */
		at += 32;

		/* Align for `ioParadigmClass` field */
		_ALIGN(at, 8);

		/* Add `ioParadigmClass` bit array field's size */
		at += 8;

		/* Align for `ioParadigmFlags` field */
		_ALIGN(at, 32);

		/* Add `ioParadigmFlags` bit array field's size */
		at += 32;

		/* Align for `numberOfProperties` field */
		_ALIGN(at, 8);

		/* Add `numberOfProperties` bit array field's size */
		at += 8;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_IoParadigmProperty(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 8);

		/* Align for `ioParadigm` field */
		_ALIGN(at, 8);

		/* Add `ioParadigm` bit array field's size */
		at += 8;

		/* Align for `ioParadigmProperty` field */
		_ALIGN(at, 8);

		/* Add `ioParadigmProperty` bit array field's size */
		at += 8;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_IoPreCreatedHandleState(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `ioHandle` field */
		_ALIGN(at, 32);

		/* Add `ioHandle` bit array field's size */
		at += 32;

		/* Align for `mode` field */
		_ALIGN(at, 8);

		/* Add `mode` bit array field's size */
		at += 8;

		/* Align for `statusFlags` field */
		_ALIGN(at, 32);

		/* Add `statusFlags` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_IoRegularFile(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `self` field */
		_ALIGN(at, 32);

		/* Add `self` bit array field's size */
		at += 32;

		/* Align for `name` field */
		_ALIGN(at, 32);

		/* Add `name` bit array field's size */
		at += 32;

		/* Align for `scope` field */
		_ALIGN(at, 32);

		/* Add `scope` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_Location(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `self` field */
		_ALIGN(at, 64);

		/* Add `self` bit array field's size */
		at += 64;

		/* Align for `name` field */
		_ALIGN(at, 32);

		/* Add `name` bit array field's size */
		at += 32;

		/* Align for `locationType` field */
		_ALIGN(at, 8);

		/* Add `locationType` bit array field's size */
		at += 8;

		/* Align for `numberOfEvents` field */
		_ALIGN(at, 64);

		/* Add `numberOfEvents` bit array field's size */
		at += 64;

		/* Align for `locationGroup` field */
		_ALIGN(at, 32);

		/* Add `locationGroup` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_LocationGroup(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `self` field */
		_ALIGN(at, 32);

		/* Add `self` bit array field's size */
		at += 32;

		/* Align for `name` field */
		_ALIGN(at, 32);

		/* Add `name` bit array field's size */
		at += 32;

		/* Align for `locationGroupType` field */
		_ALIGN(at, 8);

		/* Add `locationGroupType` bit array field's size */
		at += 8;

		/* Align for `systemTreeParent` field */
		_ALIGN(at, 32);

		/* Add `systemTreeParent` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_LocationGroupProperty(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `locationGroup` field */
		_ALIGN(at, 32);

		/* Add `locationGroup` bit array field's size */
		at += 32;

		/* Align for `name` field */
		_ALIGN(at, 32);

		/* Add `name` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_LocationProperty(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `location` field */
		_ALIGN(at, 64);

		/* Add `location` bit array field's size */
		at += 64;

		/* Align for `name` field */
		_ALIGN(at, 32);

		/* Add `name` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_MetricClass(void * const vctx,
	const uint32_t p___metricMembers_len,
	const uint32_t * const p_metricMembers)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `self` field */
		_ALIGN(at, 32);

		/* Add `self` bit array field's size */
		at += 32;

		/* Align for `__metricMembers_len` field */
		_ALIGN(at, 8);

		/* Add `__metricMembers_len` bit array field's size */
		at += 32;

		/* Align for `metricMembers` field */
		_ALIGN(at, 32);

		/* Write `metricMembers` field */
		{
			uint32_t i;

			for (i = 0; i < (uint32_t) p___metricMembers_len; ++i) {
				/* Align for `[i]` field */
				_ALIGN(at, 32);

				/* Add `[i]` bit array field's size */
				at += 32;
			}
		}

		/* Align for `metricOccurrence` field */
		_ALIGN(at, 8);

		/* Add `metricOccurrence` bit array field's size */
		at += 8;

		/* Align for `recorderKind` field */
		_ALIGN(at, 8);

		/* Add `recorderKind` bit array field's size */
		at += 8;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_MetricClassRecorder(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `metric` field */
		_ALIGN(at, 32);

		/* Add `metric` bit array field's size */
		at += 32;

		/* Align for `recorder` field */
		_ALIGN(at, 64);

		/* Add `recorder` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_MetricInstance(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `self` field */
		_ALIGN(at, 32);

		/* Add `self` bit array field's size */
		at += 32;

		/* Align for `metricClass` field */
		_ALIGN(at, 32);

		/* Add `metricClass` bit array field's size */
		at += 32;

		/* Align for `recorder` field */
		_ALIGN(at, 64);

		/* Add `recorder` bit array field's size */
		at += 64;

		/* Align for `metricScope` field */
		_ALIGN(at, 8);

		/* Add `metricScope` bit array field's size */
		at += 8;

		/* Align for `scope` field */
		_ALIGN(at, 64);

		/* Add `scope` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_MetricMember(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `self` field */
		_ALIGN(at, 32);

		/* Add `self` bit array field's size */
		at += 32;

		/* Align for `name` field */
		_ALIGN(at, 32);

		/* Add `name` bit array field's size */
		at += 32;

		/* Align for `description` field */
		_ALIGN(at, 32);

		/* Add `description` bit array field's size */
		at += 32;

		/* Align for `metricType` field */
		_ALIGN(at, 8);

		/* Add `metricType` bit array field's size */
		at += 8;

		/* Align for `metricMode` field */
		_ALIGN(at, 8);

		/* Add `metricMode` bit array field's size */
		at += 8;

		/* Align for `valueType` field */
		_ALIGN(at, 8);

		/* Add `valueType` bit array field's size */
		at += 8;

		/* Align for `base` field */
		_ALIGN(at, 8);

		/* Add `base` bit array field's size */
		at += 8;

		/* Align for `exponent` field */
		_ALIGN(at, 64);

		/* Add `exponent` bit array field's size */
		at += 64;

		/* Align for `unit` field */
		_ALIGN(at, 32);

		/* Add `unit` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_Paradigm(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `paradigm` field */
		_ALIGN(at, 8);

		/* Add `paradigm` bit array field's size */
		at += 8;

		/* Align for `name` field */
		_ALIGN(at, 32);

		/* Add `name` bit array field's size */
		at += 32;

		/* Align for `paradigmClass` field */
		_ALIGN(at, 8);

		/* Add `paradigmClass` bit array field's size */
		at += 8;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_ParadigmProperty(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 8);

		/* Align for `paradigm` field */
		_ALIGN(at, 8);

		/* Add `paradigm` bit array field's size */
		at += 8;

		/* Align for `property` field */
		_ALIGN(at, 8);

		/* Add `property` bit array field's size */
		at += 8;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_Parameter(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `self` field */
		_ALIGN(at, 32);

		/* Add `self` bit array field's size */
		at += 32;

		/* Align for `name` field */
		_ALIGN(at, 32);

		/* Add `name` bit array field's size */
		at += 32;

		/* Align for `parameterType` field */
		_ALIGN(at, 8);

		/* Add `parameterType` bit array field's size */
		at += 8;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_Region(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `self` field */
		_ALIGN(at, 32);

		/* Add `self` bit array field's size */
		at += 32;

		/* Align for `name` field */
		_ALIGN(at, 32);

		/* Add `name` bit array field's size */
		at += 32;

		/* Align for `canonicalName` field */
		_ALIGN(at, 32);

		/* Add `canonicalName` bit array field's size */
		at += 32;

		/* Align for `description` field */
		_ALIGN(at, 32);

		/* Add `description` bit array field's size */
		at += 32;

		/* Align for `regionRole` field */
		_ALIGN(at, 8);

		/* Add `regionRole` bit array field's size */
		at += 8;

		/* Align for `paradigm` field */
		_ALIGN(at, 8);

		/* Add `paradigm` bit array field's size */
		at += 8;

		/* Align for `regionFlag` field */
		_ALIGN(at, 32);

		/* Add `regionFlag` bit array field's size */
		at += 32;

		/* Align for `sourceFile` field */
		_ALIGN(at, 32);

		/* Add `sourceFile` bit array field's size */
		at += 32;

		/* Align for `beginLineNumber` field */
		_ALIGN(at, 32);

		/* Add `beginLineNumber` bit array field's size */
		at += 32;

		/* Align for `endLineNumber` field */
		_ALIGN(at, 32);

		/* Add `endLineNumber` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_RmaWin(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `self` field */
		_ALIGN(at, 32);

		/* Add `self` bit array field's size */
		at += 32;

		/* Align for `name` field */
		_ALIGN(at, 32);

		/* Add `name` bit array field's size */
		at += 32;

		/* Align for `comm` field */
		_ALIGN(at, 32);

		/* Add `comm` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_SourceCodeLocation(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `self` field */
		_ALIGN(at, 32);

		/* Add `self` bit array field's size */
		at += 32;

		/* Align for `file` field */
		_ALIGN(at, 32);

		/* Add `file` bit array field's size */
		at += 32;

		/* Align for `lineNumber` field */
		_ALIGN(at, 32);

		/* Add `lineNumber` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_String(void * const vctx,
	const char * const p_stringValue)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `self` field */
		_ALIGN(at, 32);

		/* Add `self` bit array field's size */
		at += 32;

		/* Align for `stringValue` field */
		_ALIGN(at, 8);

		/* Add `stringValue` string field's size */
		at += _BYTES_TO_BITS(strlen(p_stringValue) + 1);
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_SystemTreeNode(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `self` field */
		_ALIGN(at, 32);

		/* Add `self` bit array field's size */
		at += 32;

		/* Align for `name` field */
		_ALIGN(at, 32);

		/* Add `name` bit array field's size */
		at += 32;

		/* Align for `className` field */
		_ALIGN(at, 32);

		/* Add `className` bit array field's size */
		at += 32;

		/* Align for `systemTreeParent` field */
		_ALIGN(at, 32);

		/* Add `systemTreeParent` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_SystemTreeNodeDomain(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `systemTreeNode` field */
		_ALIGN(at, 32);

		/* Add `systemTreeNode` bit array field's size */
		at += 32;

		/* Align for `systemTreeDomain` field */
		_ALIGN(at, 8);

		/* Add `systemTreeDomain` bit array field's size */
		at += 8;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_GlobalDef_SystemTreeNodeProperty(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `systemTreeNode` field */
		_ALIGN(at, 32);

		/* Add `systemTreeNode` bit array field's size */
		at += 32;

		/* Align for `name` field */
		_ALIGN(at, 32);

		/* Add `name` bit array field's size */
		at += 32;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_MetricValue_Double(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `metricValue` field */
		_ALIGN(at, 64);

		/* Add `metricValue` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_MetricValue_Int64(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `metricValue` field */
		_ALIGN(at, 64);

		/* Add `metricValue` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_MetricValue_UInt64(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `metricValue` field */
		_ALIGN(at, 64);

		/* Add `metricValue` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

/* Trace (data stream type `default`, event record type `EventAttribute_Attribute`) */
void barectf_default_trace_EventAttribute_Attribute(struct barectf_default_ctx * const sctx,
	const uint32_t p_attribute,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_EventAttribute_Attribute(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_EventAttribute_Attribute(_TO_VOID_PTR(ctx), p_attribute, p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `EventAttribute_CallingContext`) */
void barectf_default_trace_EventAttribute_CallingContext(struct barectf_default_ctx * const sctx,
	const uint32_t p_attribute,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_EventAttribute_CallingContext(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_EventAttribute_CallingContext(_TO_VOID_PTR(ctx), p_attribute, p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `EventAttribute_Comm`) */
void barectf_default_trace_EventAttribute_Comm(struct barectf_default_ctx * const sctx,
	const uint32_t p_attribute,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_EventAttribute_Comm(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_EventAttribute_Comm(_TO_VOID_PTR(ctx), p_attribute, p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `EventAttribute_Double`) */
void barectf_default_trace_EventAttribute_Double(struct barectf_default_ctx * const sctx,
	const uint32_t p_attribute,
	const double p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_EventAttribute_Double(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_EventAttribute_Double(_TO_VOID_PTR(ctx), p_attribute, p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `EventAttribute_Float`) */
void barectf_default_trace_EventAttribute_Float(struct barectf_default_ctx * const sctx,
	const uint32_t p_attribute,
	const float p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_EventAttribute_Float(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_EventAttribute_Float(_TO_VOID_PTR(ctx), p_attribute, p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `EventAttribute_Group`) */
void barectf_default_trace_EventAttribute_Group(struct barectf_default_ctx * const sctx,
	const uint32_t p_attribute,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_EventAttribute_Group(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_EventAttribute_Group(_TO_VOID_PTR(ctx), p_attribute, p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `EventAttribute_Int16`) */
void barectf_default_trace_EventAttribute_Int16(struct barectf_default_ctx * const sctx,
	const uint32_t p_attribute,
	const int16_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_EventAttribute_Int16(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_EventAttribute_Int16(_TO_VOID_PTR(ctx), p_attribute, p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `EventAttribute_Int32`) */
void barectf_default_trace_EventAttribute_Int32(struct barectf_default_ctx * const sctx,
	const uint32_t p_attribute,
	const int32_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_EventAttribute_Int32(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_EventAttribute_Int32(_TO_VOID_PTR(ctx), p_attribute, p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `EventAttribute_Int64`) */
void barectf_default_trace_EventAttribute_Int64(struct barectf_default_ctx * const sctx,
	const uint32_t p_attribute,
	const int64_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_EventAttribute_Int64(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_EventAttribute_Int64(_TO_VOID_PTR(ctx), p_attribute, p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `EventAttribute_Int8`) */
void barectf_default_trace_EventAttribute_Int8(struct barectf_default_ctx * const sctx,
	const uint32_t p_attribute,
	const int8_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_EventAttribute_Int8(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_EventAttribute_Int8(_TO_VOID_PTR(ctx), p_attribute, p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `EventAttribute_InterruptGenerator`) */
void barectf_default_trace_EventAttribute_InterruptGenerator(struct barectf_default_ctx * const sctx,
	const uint32_t p_attribute,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_EventAttribute_InterruptGenerator(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_EventAttribute_InterruptGenerator(_TO_VOID_PTR(ctx), p_attribute, p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `EventAttribute_IoFile`) */
void barectf_default_trace_EventAttribute_IoFile(struct barectf_default_ctx * const sctx,
	const uint32_t p_attribute,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_EventAttribute_IoFile(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_EventAttribute_IoFile(_TO_VOID_PTR(ctx), p_attribute, p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `EventAttribute_IoHandle`) */
void barectf_default_trace_EventAttribute_IoHandle(struct barectf_default_ctx * const sctx,
	const uint32_t p_attribute,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_EventAttribute_IoHandle(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_EventAttribute_IoHandle(_TO_VOID_PTR(ctx), p_attribute, p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `EventAttribute_Location`) */
void barectf_default_trace_EventAttribute_Location(struct barectf_default_ctx * const sctx,
	const uint32_t p_attribute,
	const uint64_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_EventAttribute_Location(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_EventAttribute_Location(_TO_VOID_PTR(ctx), p_attribute, p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `EventAttribute_Metric`) */
void barectf_default_trace_EventAttribute_Metric(struct barectf_default_ctx * const sctx,
	const uint32_t p_attribute,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_EventAttribute_Metric(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_EventAttribute_Metric(_TO_VOID_PTR(ctx), p_attribute, p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `EventAttribute_Parameter`) */
void barectf_default_trace_EventAttribute_Parameter(struct barectf_default_ctx * const sctx,
	const uint32_t p_attribute,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_EventAttribute_Parameter(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_EventAttribute_Parameter(_TO_VOID_PTR(ctx), p_attribute, p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `EventAttribute_Region`) */
void barectf_default_trace_EventAttribute_Region(struct barectf_default_ctx * const sctx,
	const uint32_t p_attribute,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_EventAttribute_Region(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_EventAttribute_Region(_TO_VOID_PTR(ctx), p_attribute, p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `EventAttribute_RmaWin`) */
void barectf_default_trace_EventAttribute_RmaWin(struct barectf_default_ctx * const sctx,
	const uint32_t p_attribute,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_EventAttribute_RmaWin(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_EventAttribute_RmaWin(_TO_VOID_PTR(ctx), p_attribute, p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `EventAttribute_SourceCodeLocation`) */
void barectf_default_trace_EventAttribute_SourceCodeLocation(struct barectf_default_ctx * const sctx,
	const uint32_t p_attribute,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_EventAttribute_SourceCodeLocation(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_EventAttribute_SourceCodeLocation(_TO_VOID_PTR(ctx), p_attribute, p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `EventAttribute_String`) */
void barectf_default_trace_EventAttribute_String(struct barectf_default_ctx * const sctx,
	const uint32_t p_attribute,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_EventAttribute_String(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_EventAttribute_String(_TO_VOID_PTR(ctx), p_attribute, p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `EventAttribute_UInt16`) */
void barectf_default_trace_EventAttribute_UInt16(struct barectf_default_ctx * const sctx,
	const uint32_t p_attribute,
	const uint16_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_EventAttribute_UInt16(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_EventAttribute_UInt16(_TO_VOID_PTR(ctx), p_attribute, p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `EventAttribute_UInt32`) */
void barectf_default_trace_EventAttribute_UInt32(struct barectf_default_ctx * const sctx,
	const uint32_t p_attribute,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_EventAttribute_UInt32(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_EventAttribute_UInt32(_TO_VOID_PTR(ctx), p_attribute, p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `EventAttribute_UInt64`) */
void barectf_default_trace_EventAttribute_UInt64(struct barectf_default_ctx * const sctx,
	const uint32_t p_attribute,
	const uint64_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_EventAttribute_UInt64(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_EventAttribute_UInt64(_TO_VOID_PTR(ctx), p_attribute, p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `EventAttribute_UInt8`) */
void barectf_default_trace_EventAttribute_UInt8(struct barectf_default_ctx * const sctx,
	const uint32_t p_attribute,
	const uint8_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_EventAttribute_UInt8(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_EventAttribute_UInt8(_TO_VOID_PTR(ctx), p_attribute, p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_BufferFlush`) */
void barectf_default_trace_Event_BufferFlush(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint64_t p_stopTime)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_BufferFlush(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_BufferFlush(_TO_VOID_PTR(ctx), p_locationID, p_stopTime);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_CallingContextEnter`) */
void barectf_default_trace_Event_CallingContextEnter(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_callingContext,
	const uint32_t p_unwindDistance)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_CallingContextEnter(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_CallingContextEnter(_TO_VOID_PTR(ctx), p_locationID, p_callingContext, p_unwindDistance);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_CallingContextLeave`) */
void barectf_default_trace_Event_CallingContextLeave(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_callingContext)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_CallingContextLeave(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_CallingContextLeave(_TO_VOID_PTR(ctx), p_locationID, p_callingContext);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_CallingContextSample`) */
void barectf_default_trace_Event_CallingContextSample(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_callingContext,
	const uint32_t p_unwindDistance,
	const uint32_t p_interruptGenerator)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_CallingContextSample(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_CallingContextSample(_TO_VOID_PTR(ctx), p_locationID, p_callingContext, p_unwindDistance, p_interruptGenerator);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_Enter`) */
void barectf_default_trace_Event_Enter(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_region)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_Enter(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_Enter(_TO_VOID_PTR(ctx), p_locationID, p_region);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_IoAcquireLock`) */
void barectf_default_trace_Event_IoAcquireLock(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_handle,
	const uint8_t p_lockType)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_IoAcquireLock(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_IoAcquireLock(_TO_VOID_PTR(ctx), p_locationID, p_handle, p_lockType);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_IoChangeStatusFlags`) */
void barectf_default_trace_Event_IoChangeStatusFlags(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_handle,
	const uint32_t p_statusFlags)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_IoChangeStatusFlags(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_IoChangeStatusFlags(_TO_VOID_PTR(ctx), p_locationID, p_handle, p_statusFlags);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_IoCreateHandle`) */
void barectf_default_trace_Event_IoCreateHandle(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_handle,
	const uint8_t p_mode,
	const uint32_t p_creationFlags,
	const uint32_t p_statusFlags)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_IoCreateHandle(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_IoCreateHandle(_TO_VOID_PTR(ctx), p_locationID, p_handle, p_mode, p_creationFlags, p_statusFlags);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_IoDeleteFile`) */
void barectf_default_trace_Event_IoDeleteFile(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint8_t p_ioParadigm,
	const uint32_t p_file)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_IoDeleteFile(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_IoDeleteFile(_TO_VOID_PTR(ctx), p_locationID, p_ioParadigm, p_file);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_IoDestroyHandle`) */
void barectf_default_trace_Event_IoDestroyHandle(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_handle)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_IoDestroyHandle(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_IoDestroyHandle(_TO_VOID_PTR(ctx), p_locationID, p_handle);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_IoDuplicateHandle`) */
void barectf_default_trace_Event_IoDuplicateHandle(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_oldHandle,
	const uint32_t p_newHandle,
	const uint32_t p_statusFlags)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_IoDuplicateHandle(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_IoDuplicateHandle(_TO_VOID_PTR(ctx), p_locationID, p_oldHandle, p_newHandle, p_statusFlags);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_IoOperationBegin`) */
void barectf_default_trace_Event_IoOperationBegin(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_handle,
	const uint8_t p_mode,
	const uint32_t p_operationFlags,
	const uint64_t p_bytesRequest,
	const uint64_t p_matchingId)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_IoOperationBegin(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_IoOperationBegin(_TO_VOID_PTR(ctx), p_locationID, p_handle, p_mode, p_operationFlags, p_bytesRequest, p_matchingId);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_IoOperationCancelled`) */
void barectf_default_trace_Event_IoOperationCancelled(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_handle,
	const uint64_t p_matchingId)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_IoOperationCancelled(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_IoOperationCancelled(_TO_VOID_PTR(ctx), p_locationID, p_handle, p_matchingId);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_IoOperationComplete`) */
void barectf_default_trace_Event_IoOperationComplete(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_handle,
	const uint64_t p_bytesResult,
	const uint64_t p_matchingId)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_IoOperationComplete(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_IoOperationComplete(_TO_VOID_PTR(ctx), p_locationID, p_handle, p_bytesResult, p_matchingId);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_IoOperationIssued`) */
void barectf_default_trace_Event_IoOperationIssued(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_handle,
	const uint64_t p_matchingId)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_IoOperationIssued(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_IoOperationIssued(_TO_VOID_PTR(ctx), p_locationID, p_handle, p_matchingId);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_IoOperationTest`) */
void barectf_default_trace_Event_IoOperationTest(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_handle,
	const uint64_t p_matchingId)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_IoOperationTest(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_IoOperationTest(_TO_VOID_PTR(ctx), p_locationID, p_handle, p_matchingId);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_IoReleaseLock`) */
void barectf_default_trace_Event_IoReleaseLock(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_handle,
	const uint8_t p_lockType)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_IoReleaseLock(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_IoReleaseLock(_TO_VOID_PTR(ctx), p_locationID, p_handle, p_lockType);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_IoSeek`) */
void barectf_default_trace_Event_IoSeek(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_handle,
	const int64_t p_offsetRequest,
	const uint8_t p_whence,
	const uint64_t p_offsetResult)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_IoSeek(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_IoSeek(_TO_VOID_PTR(ctx), p_locationID, p_handle, p_offsetRequest, p_whence, p_offsetResult);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_IoTryLock`) */
void barectf_default_trace_Event_IoTryLock(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_handle,
	const uint8_t p_lockType)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_IoTryLock(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_IoTryLock(_TO_VOID_PTR(ctx), p_locationID, p_handle, p_lockType);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_Leave`) */
void barectf_default_trace_Event_Leave(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_region)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_Leave(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_Leave(_TO_VOID_PTR(ctx), p_locationID, p_region);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_MeasurementOnOff`) */
void barectf_default_trace_Event_MeasurementOnOff(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint8_t p_measurementMode)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_MeasurementOnOff(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_MeasurementOnOff(_TO_VOID_PTR(ctx), p_locationID, p_measurementMode);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_Metric`) */
void barectf_default_trace_Event_Metric(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_metric,
	const uint8_t p_numberOfMetrics)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_Metric(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_Metric(_TO_VOID_PTR(ctx), p_locationID, p_metric, p_numberOfMetrics);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_MpiCollectiveBegin`) */
void barectf_default_trace_Event_MpiCollectiveBegin(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_MpiCollectiveBegin(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_MpiCollectiveBegin(_TO_VOID_PTR(ctx), p_locationID);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_MpiCollectiveEnd`) */
void barectf_default_trace_Event_MpiCollectiveEnd(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint8_t p_collectiveOp,
	const uint32_t p_communicator,
	const uint32_t p_root,
	const uint64_t p_sizeSent,
	const uint64_t p_sizeReceived)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_MpiCollectiveEnd(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_MpiCollectiveEnd(_TO_VOID_PTR(ctx), p_locationID, p_collectiveOp, p_communicator, p_root, p_sizeSent, p_sizeReceived);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_MpiIrecv`) */
void barectf_default_trace_Event_MpiIrecv(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_receiver,
	const uint32_t p_communicator,
	const uint32_t p_msgTag,
	const uint64_t p_msgLength,
	const uint64_t p_requestID)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_MpiIrecv(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_MpiIrecv(_TO_VOID_PTR(ctx), p_locationID, p_receiver, p_communicator, p_msgTag, p_msgLength, p_requestID);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_MpiIrecvRequest`) */
void barectf_default_trace_Event_MpiIrecvRequest(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint64_t p_requestID)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_MpiIrecvRequest(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_MpiIrecvRequest(_TO_VOID_PTR(ctx), p_locationID, p_requestID);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_MpiIsend`) */
void barectf_default_trace_Event_MpiIsend(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_receiver,
	const uint32_t p_communicator,
	const uint32_t p_msgTag,
	const uint64_t p_msgLength,
	const uint64_t p_requestID)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_MpiIsend(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_MpiIsend(_TO_VOID_PTR(ctx), p_locationID, p_receiver, p_communicator, p_msgTag, p_msgLength, p_requestID);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_MpiIsendComplete`) */
void barectf_default_trace_Event_MpiIsendComplete(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint64_t p_requestID)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_MpiIsendComplete(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_MpiIsendComplete(_TO_VOID_PTR(ctx), p_locationID, p_requestID);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_MpiRecv`) */
void barectf_default_trace_Event_MpiRecv(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_sender,
	const uint32_t p_communicator,
	const uint32_t p_msgTag,
	const uint64_t p_msgLength)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_MpiRecv(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_MpiRecv(_TO_VOID_PTR(ctx), p_locationID, p_sender, p_communicator, p_msgTag, p_msgLength);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_MpiRequestCancelled`) */
void barectf_default_trace_Event_MpiRequestCancelled(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint64_t p_requestID)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_MpiRequestCancelled(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_MpiRequestCancelled(_TO_VOID_PTR(ctx), p_locationID, p_requestID);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_MpiRequestTest`) */
void barectf_default_trace_Event_MpiRequestTest(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint64_t p_requestID)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_MpiRequestTest(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_MpiRequestTest(_TO_VOID_PTR(ctx), p_locationID, p_requestID);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_MpiSend`) */
void barectf_default_trace_Event_MpiSend(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_receiver,
	const uint32_t p_communicator,
	const uint32_t p_msgTag,
	const uint64_t p_msgLength)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_MpiSend(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_MpiSend(_TO_VOID_PTR(ctx), p_locationID, p_receiver, p_communicator, p_msgTag, p_msgLength);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_OmpAcquireLock`) */
void barectf_default_trace_Event_OmpAcquireLock(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_lockID,
	const uint32_t p_acquisitionOrder)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_OmpAcquireLock(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_OmpAcquireLock(_TO_VOID_PTR(ctx), p_locationID, p_lockID, p_acquisitionOrder);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_OmpFork`) */
void barectf_default_trace_Event_OmpFork(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_numberOfRequestedThreads)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_OmpFork(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_OmpFork(_TO_VOID_PTR(ctx), p_locationID, p_numberOfRequestedThreads);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_OmpJoin`) */
void barectf_default_trace_Event_OmpJoin(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_OmpJoin(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_OmpJoin(_TO_VOID_PTR(ctx), p_locationID);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_OmpReleaseLock`) */
void barectf_default_trace_Event_OmpReleaseLock(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_lockID,
	const uint32_t p_acquisitionOrder)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_OmpReleaseLock(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_OmpReleaseLock(_TO_VOID_PTR(ctx), p_locationID, p_lockID, p_acquisitionOrder);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_OmpTaskComplete`) */
void barectf_default_trace_Event_OmpTaskComplete(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint64_t p_taskID)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_OmpTaskComplete(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_OmpTaskComplete(_TO_VOID_PTR(ctx), p_locationID, p_taskID);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_OmpTaskCreate`) */
void barectf_default_trace_Event_OmpTaskCreate(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint64_t p_taskID)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_OmpTaskCreate(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_OmpTaskCreate(_TO_VOID_PTR(ctx), p_locationID, p_taskID);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_OmpTaskSwitch`) */
void barectf_default_trace_Event_OmpTaskSwitch(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint64_t p_taskID)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_OmpTaskSwitch(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_OmpTaskSwitch(_TO_VOID_PTR(ctx), p_locationID, p_taskID);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_ParameterInt`) */
void barectf_default_trace_Event_ParameterInt(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_parameter,
	const int64_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_ParameterInt(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_ParameterInt(_TO_VOID_PTR(ctx), p_locationID, p_parameter, p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_ParameterString`) */
void barectf_default_trace_Event_ParameterString(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_parameter,
	const uint32_t p_stringID)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_ParameterString(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_ParameterString(_TO_VOID_PTR(ctx), p_locationID, p_parameter, p_stringID);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_ParameterUnsignedInt`) */
void barectf_default_trace_Event_ParameterUnsignedInt(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_parameter,
	const uint64_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_ParameterUnsignedInt(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_ParameterUnsignedInt(_TO_VOID_PTR(ctx), p_locationID, p_parameter, p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_ProgramArgument`) */
void barectf_default_trace_Event_ProgramArgument(struct barectf_default_ctx * const sctx,
	const uint32_t p_programArgument)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_ProgramArgument(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_ProgramArgument(_TO_VOID_PTR(ctx), p_programArgument);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_ProgramBegin`) */
void barectf_default_trace_Event_ProgramBegin(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_programName)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_ProgramBegin(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_ProgramBegin(_TO_VOID_PTR(ctx), p_locationID, p_programName);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_ProgramEnd`) */
void barectf_default_trace_Event_ProgramEnd(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const int64_t p_exitStatus)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_ProgramEnd(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_ProgramEnd(_TO_VOID_PTR(ctx), p_locationID, p_exitStatus);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_RmaAcquireLock`) */
void barectf_default_trace_Event_RmaAcquireLock(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_win,
	const uint32_t p_remote,
	const uint64_t p_lockId,
	const uint8_t p_lockType)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_RmaAcquireLock(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_RmaAcquireLock(_TO_VOID_PTR(ctx), p_locationID, p_win, p_remote, p_lockId, p_lockType);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_RmaAtomic`) */
void barectf_default_trace_Event_RmaAtomic(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_win,
	const uint32_t p_remote,
	const uint8_t p_type,
	const uint64_t p_bytesSent,
	const uint64_t p_bytesReceived,
	const uint64_t p_matchingId)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_RmaAtomic(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_RmaAtomic(_TO_VOID_PTR(ctx), p_locationID, p_win, p_remote, p_type, p_bytesSent, p_bytesReceived, p_matchingId);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_RmaCollectiveBegin`) */
void barectf_default_trace_Event_RmaCollectiveBegin(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_RmaCollectiveBegin(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_RmaCollectiveBegin(_TO_VOID_PTR(ctx), p_locationID);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_RmaCollectiveEnd`) */
void barectf_default_trace_Event_RmaCollectiveEnd(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint8_t p_collectiveOp,
	const uint32_t p_syncLevel,
	const uint32_t p_win,
	const uint32_t p_root,
	const uint64_t p_bytesSent,
	const uint64_t p_bytesReceived)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_RmaCollectiveEnd(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_RmaCollectiveEnd(_TO_VOID_PTR(ctx), p_locationID, p_collectiveOp, p_syncLevel, p_win, p_root, p_bytesSent, p_bytesReceived);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_RmaGet`) */
void barectf_default_trace_Event_RmaGet(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_win,
	const uint32_t p_remote,
	const uint64_t p_bytes,
	const uint64_t p_matchingId)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_RmaGet(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_RmaGet(_TO_VOID_PTR(ctx), p_locationID, p_win, p_remote, p_bytes, p_matchingId);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_RmaGroupSync`) */
void barectf_default_trace_Event_RmaGroupSync(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_syncLevel,
	const uint32_t p_win,
	const uint32_t p_group)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_RmaGroupSync(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_RmaGroupSync(_TO_VOID_PTR(ctx), p_locationID, p_syncLevel, p_win, p_group);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_RmaOpCompleteBlocking`) */
void barectf_default_trace_Event_RmaOpCompleteBlocking(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_win,
	const uint64_t p_matchingId)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_RmaOpCompleteBlocking(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_RmaOpCompleteBlocking(_TO_VOID_PTR(ctx), p_locationID, p_win, p_matchingId);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_RmaOpCompleteNonBlocking`) */
void barectf_default_trace_Event_RmaOpCompleteNonBlocking(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_win,
	const uint64_t p_matchingId)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_RmaOpCompleteNonBlocking(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_RmaOpCompleteNonBlocking(_TO_VOID_PTR(ctx), p_locationID, p_win, p_matchingId);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_RmaOpCompleteRemote`) */
void barectf_default_trace_Event_RmaOpCompleteRemote(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_win,
	const uint64_t p_matchingId)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_RmaOpCompleteRemote(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_RmaOpCompleteRemote(_TO_VOID_PTR(ctx), p_locationID, p_win, p_matchingId);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_RmaOpTest`) */
void barectf_default_trace_Event_RmaOpTest(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_win,
	const uint64_t p_matchingId)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_RmaOpTest(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_RmaOpTest(_TO_VOID_PTR(ctx), p_locationID, p_win, p_matchingId);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_RmaPut`) */
void barectf_default_trace_Event_RmaPut(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_win,
	const uint32_t p_remote,
	const uint64_t p_bytes,
	const uint64_t p_matchingId)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_RmaPut(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_RmaPut(_TO_VOID_PTR(ctx), p_locationID, p_win, p_remote, p_bytes, p_matchingId);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_RmaReleaseLock`) */
void barectf_default_trace_Event_RmaReleaseLock(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_win,
	const uint32_t p_remote,
	const uint64_t p_lockId)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_RmaReleaseLock(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_RmaReleaseLock(_TO_VOID_PTR(ctx), p_locationID, p_win, p_remote, p_lockId);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_RmaRequestLock`) */
void barectf_default_trace_Event_RmaRequestLock(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_win,
	const uint32_t p_remote,
	const uint64_t p_lockId,
	const uint8_t p_lockType)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_RmaRequestLock(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_RmaRequestLock(_TO_VOID_PTR(ctx), p_locationID, p_win, p_remote, p_lockId, p_lockType);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_RmaSync`) */
void barectf_default_trace_Event_RmaSync(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_win,
	const uint32_t p_remote,
	const uint8_t p_syncType)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_RmaSync(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_RmaSync(_TO_VOID_PTR(ctx), p_locationID, p_win, p_remote, p_syncType);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_RmaTryLock`) */
void barectf_default_trace_Event_RmaTryLock(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_win,
	const uint32_t p_remote,
	const uint64_t p_lockId,
	const uint8_t p_lockType)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_RmaTryLock(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_RmaTryLock(_TO_VOID_PTR(ctx), p_locationID, p_win, p_remote, p_lockId, p_lockType);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_RmaWaitChange`) */
void barectf_default_trace_Event_RmaWaitChange(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_win)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_RmaWaitChange(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_RmaWaitChange(_TO_VOID_PTR(ctx), p_locationID, p_win);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_RmaWinCreate`) */
void barectf_default_trace_Event_RmaWinCreate(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_win)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_RmaWinCreate(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_RmaWinCreate(_TO_VOID_PTR(ctx), p_locationID, p_win);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_RmaWinDestroy`) */
void barectf_default_trace_Event_RmaWinDestroy(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_win)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_RmaWinDestroy(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_RmaWinDestroy(_TO_VOID_PTR(ctx), p_locationID, p_win);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_ThreadAcquireLock`) */
void barectf_default_trace_Event_ThreadAcquireLock(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint8_t p_model,
	const uint32_t p_lockID,
	const uint32_t p_acquisitionOrder)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_ThreadAcquireLock(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_ThreadAcquireLock(_TO_VOID_PTR(ctx), p_locationID, p_model, p_lockID, p_acquisitionOrder);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_ThreadBegin`) */
void barectf_default_trace_Event_ThreadBegin(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_threadContingent,
	const uint64_t p_sequenceCount)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_ThreadBegin(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_ThreadBegin(_TO_VOID_PTR(ctx), p_locationID, p_threadContingent, p_sequenceCount);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_ThreadCreate`) */
void barectf_default_trace_Event_ThreadCreate(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_threadContingent,
	const uint64_t p_sequenceCount)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_ThreadCreate(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_ThreadCreate(_TO_VOID_PTR(ctx), p_locationID, p_threadContingent, p_sequenceCount);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_ThreadEnd`) */
void barectf_default_trace_Event_ThreadEnd(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_threadContingent,
	const uint64_t p_sequenceCount)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_ThreadEnd(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_ThreadEnd(_TO_VOID_PTR(ctx), p_locationID, p_threadContingent, p_sequenceCount);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_ThreadFork`) */
void barectf_default_trace_Event_ThreadFork(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint8_t p_model,
	const uint32_t p_matchnumberOfRequestedThreadsingId)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_ThreadFork(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_ThreadFork(_TO_VOID_PTR(ctx), p_locationID, p_model, p_matchnumberOfRequestedThreadsingId);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_ThreadJoin`) */
void barectf_default_trace_Event_ThreadJoin(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint8_t p_model)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_ThreadJoin(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_ThreadJoin(_TO_VOID_PTR(ctx), p_locationID, p_model);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_ThreadReleaseLock`) */
void barectf_default_trace_Event_ThreadReleaseLock(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint8_t p_model,
	const uint32_t p_lockID,
	const uint32_t p_acquisitionOrder)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_ThreadReleaseLock(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_ThreadReleaseLock(_TO_VOID_PTR(ctx), p_locationID, p_model, p_lockID, p_acquisitionOrder);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_ThreadTaskComplete`) */
void barectf_default_trace_Event_ThreadTaskComplete(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_threadTeam,
	const uint32_t p_creatingThread,
	const uint32_t p_generationNumber)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_ThreadTaskComplete(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_ThreadTaskComplete(_TO_VOID_PTR(ctx), p_locationID, p_threadTeam, p_creatingThread, p_generationNumber);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_ThreadTaskCreate`) */
void barectf_default_trace_Event_ThreadTaskCreate(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_threadTeam,
	const uint32_t p_creatingThread,
	const uint32_t p_generationNumber)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_ThreadTaskCreate(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_ThreadTaskCreate(_TO_VOID_PTR(ctx), p_locationID, p_threadTeam, p_creatingThread, p_generationNumber);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_ThreadTaskSwitch`) */
void barectf_default_trace_Event_ThreadTaskSwitch(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_threadTeam,
	const uint32_t p_creatingThread,
	const uint32_t p_generationNumber)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_ThreadTaskSwitch(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_ThreadTaskSwitch(_TO_VOID_PTR(ctx), p_locationID, p_threadTeam, p_creatingThread, p_generationNumber);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_ThreadTeamBegin`) */
void barectf_default_trace_Event_ThreadTeamBegin(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_threadTeam)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_ThreadTeamBegin(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_ThreadTeamBegin(_TO_VOID_PTR(ctx), p_locationID, p_threadTeam);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_ThreadTeamEnd`) */
void barectf_default_trace_Event_ThreadTeamEnd(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_threadTeam)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_ThreadTeamEnd(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_ThreadTeamEnd(_TO_VOID_PTR(ctx), p_locationID, p_threadTeam);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `Event_ThreadWait`) */
void barectf_default_trace_Event_ThreadWait(struct barectf_default_ctx * const sctx,
	const uint64_t p_locationID,
	const uint32_t p_threadContingent,
	const uint64_t p_sequenceCount)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_Event_ThreadWait(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_Event_ThreadWait(_TO_VOID_PTR(ctx), p_locationID, p_threadContingent, p_sequenceCount);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDefAttribute_Attribute`) */
void barectf_default_trace_GlobalDefAttribute_Attribute(struct barectf_default_ctx * const sctx,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDefAttribute_Attribute(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDefAttribute_Attribute(_TO_VOID_PTR(ctx), p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDefAttribute_CallingContext`) */
void barectf_default_trace_GlobalDefAttribute_CallingContext(struct barectf_default_ctx * const sctx,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDefAttribute_CallingContext(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDefAttribute_CallingContext(_TO_VOID_PTR(ctx), p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDefAttribute_Comm`) */
void barectf_default_trace_GlobalDefAttribute_Comm(struct barectf_default_ctx * const sctx,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDefAttribute_Comm(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDefAttribute_Comm(_TO_VOID_PTR(ctx), p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDefAttribute_Double`) */
void barectf_default_trace_GlobalDefAttribute_Double(struct barectf_default_ctx * const sctx,
	const double p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDefAttribute_Double(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDefAttribute_Double(_TO_VOID_PTR(ctx), p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDefAttribute_Float`) */
void barectf_default_trace_GlobalDefAttribute_Float(struct barectf_default_ctx * const sctx,
	const float p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDefAttribute_Float(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDefAttribute_Float(_TO_VOID_PTR(ctx), p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDefAttribute_Group`) */
void barectf_default_trace_GlobalDefAttribute_Group(struct barectf_default_ctx * const sctx,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDefAttribute_Group(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDefAttribute_Group(_TO_VOID_PTR(ctx), p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDefAttribute_Int16`) */
void barectf_default_trace_GlobalDefAttribute_Int16(struct barectf_default_ctx * const sctx,
	const int16_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDefAttribute_Int16(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDefAttribute_Int16(_TO_VOID_PTR(ctx), p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDefAttribute_Int32`) */
void barectf_default_trace_GlobalDefAttribute_Int32(struct barectf_default_ctx * const sctx,
	const int32_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDefAttribute_Int32(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDefAttribute_Int32(_TO_VOID_PTR(ctx), p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDefAttribute_Int64`) */
void barectf_default_trace_GlobalDefAttribute_Int64(struct barectf_default_ctx * const sctx,
	const int64_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDefAttribute_Int64(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDefAttribute_Int64(_TO_VOID_PTR(ctx), p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDefAttribute_Int8`) */
void barectf_default_trace_GlobalDefAttribute_Int8(struct barectf_default_ctx * const sctx,
	const int8_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDefAttribute_Int8(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDefAttribute_Int8(_TO_VOID_PTR(ctx), p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDefAttribute_InterruptGenerator`) */
void barectf_default_trace_GlobalDefAttribute_InterruptGenerator(struct barectf_default_ctx * const sctx,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDefAttribute_InterruptGenerator(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDefAttribute_InterruptGenerator(_TO_VOID_PTR(ctx), p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDefAttribute_IoFile`) */
void barectf_default_trace_GlobalDefAttribute_IoFile(struct barectf_default_ctx * const sctx,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDefAttribute_IoFile(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDefAttribute_IoFile(_TO_VOID_PTR(ctx), p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDefAttribute_IoHandle`) */
void barectf_default_trace_GlobalDefAttribute_IoHandle(struct barectf_default_ctx * const sctx,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDefAttribute_IoHandle(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDefAttribute_IoHandle(_TO_VOID_PTR(ctx), p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDefAttribute_Location`) */
void barectf_default_trace_GlobalDefAttribute_Location(struct barectf_default_ctx * const sctx,
	const uint64_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDefAttribute_Location(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDefAttribute_Location(_TO_VOID_PTR(ctx), p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDefAttribute_Metric`) */
void barectf_default_trace_GlobalDefAttribute_Metric(struct barectf_default_ctx * const sctx,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDefAttribute_Metric(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDefAttribute_Metric(_TO_VOID_PTR(ctx), p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDefAttribute_Parameter`) */
void barectf_default_trace_GlobalDefAttribute_Parameter(struct barectf_default_ctx * const sctx,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDefAttribute_Parameter(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDefAttribute_Parameter(_TO_VOID_PTR(ctx), p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDefAttribute_Region`) */
void barectf_default_trace_GlobalDefAttribute_Region(struct barectf_default_ctx * const sctx,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDefAttribute_Region(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDefAttribute_Region(_TO_VOID_PTR(ctx), p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDefAttribute_RmaWin`) */
void barectf_default_trace_GlobalDefAttribute_RmaWin(struct barectf_default_ctx * const sctx,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDefAttribute_RmaWin(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDefAttribute_RmaWin(_TO_VOID_PTR(ctx), p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDefAttribute_SourceCodeLocation`) */
void barectf_default_trace_GlobalDefAttribute_SourceCodeLocation(struct barectf_default_ctx * const sctx,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDefAttribute_SourceCodeLocation(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDefAttribute_SourceCodeLocation(_TO_VOID_PTR(ctx), p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDefAttribute_String`) */
void barectf_default_trace_GlobalDefAttribute_String(struct barectf_default_ctx * const sctx,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDefAttribute_String(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDefAttribute_String(_TO_VOID_PTR(ctx), p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDefAttribute_UInt16`) */
void barectf_default_trace_GlobalDefAttribute_UInt16(struct barectf_default_ctx * const sctx,
	const uint16_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDefAttribute_UInt16(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDefAttribute_UInt16(_TO_VOID_PTR(ctx), p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDefAttribute_UInt32`) */
void barectf_default_trace_GlobalDefAttribute_UInt32(struct barectf_default_ctx * const sctx,
	const uint32_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDefAttribute_UInt32(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDefAttribute_UInt32(_TO_VOID_PTR(ctx), p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDefAttribute_UInt64`) */
void barectf_default_trace_GlobalDefAttribute_UInt64(struct barectf_default_ctx * const sctx,
	const uint64_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDefAttribute_UInt64(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDefAttribute_UInt64(_TO_VOID_PTR(ctx), p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDefAttribute_UInt8`) */
void barectf_default_trace_GlobalDefAttribute_UInt8(struct barectf_default_ctx * const sctx,
	const uint8_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDefAttribute_UInt8(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDefAttribute_UInt8(_TO_VOID_PTR(ctx), p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_Attribute`) */
void barectf_default_trace_GlobalDef_Attribute(struct barectf_default_ctx * const sctx,
	const uint32_t p_self,
	const uint32_t p_name,
	const uint32_t p_description,
	const uint8_t p_type)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_Attribute(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_Attribute(_TO_VOID_PTR(ctx), p_self, p_name, p_description, p_type);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_CallingContext`) */
void barectf_default_trace_GlobalDef_CallingContext(struct barectf_default_ctx * const sctx,
	const uint32_t p_self,
	const uint32_t p_region,
	const uint32_t p_sourceCodeLocation,
	const uint32_t p_parent)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_CallingContext(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_CallingContext(_TO_VOID_PTR(ctx), p_self, p_region, p_sourceCodeLocation, p_parent);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_CallingContextProperty`) */
void barectf_default_trace_GlobalDef_CallingContextProperty(struct barectf_default_ctx * const sctx,
	const uint32_t p_callingContext,
	const uint32_t p_name)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_CallingContextProperty(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_CallingContextProperty(_TO_VOID_PTR(ctx), p_callingContext, p_name);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_Callpath`) */
void barectf_default_trace_GlobalDef_Callpath(struct barectf_default_ctx * const sctx,
	const uint32_t p_self,
	const uint32_t p_parent,
	const uint32_t p_region)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_Callpath(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_Callpath(_TO_VOID_PTR(ctx), p_self, p_parent, p_region);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_CallpathParameter`) */
void barectf_default_trace_GlobalDef_CallpathParameter(struct barectf_default_ctx * const sctx,
	const uint32_t p_callpath,
	const uint32_t p_parameter)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_CallpathParameter(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_CallpathParameter(_TO_VOID_PTR(ctx), p_callpath, p_parameter);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_Callsite`) */
void barectf_default_trace_GlobalDef_Callsite(struct barectf_default_ctx * const sctx,
	const uint32_t p_self,
	const uint32_t p_sourceFile,
	const uint32_t p_lineNumber,
	const uint32_t p_enteredRegion,
	const uint32_t p_leftRegion)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_Callsite(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_Callsite(_TO_VOID_PTR(ctx), p_self, p_sourceFile, p_lineNumber, p_enteredRegion, p_leftRegion);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_CartCoordinate`) */
void barectf_default_trace_GlobalDef_CartCoordinate(struct barectf_default_ctx * const sctx,
	const uint32_t p_cartTopology,
	const uint32_t p_rank,
	const uint32_t p___coordinates_len,
	const uint32_t * const p_coordinates)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_CartCoordinate(_TO_VOID_PTR(ctx), p___coordinates_len, p_coordinates);

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_CartCoordinate(_TO_VOID_PTR(ctx), p_cartTopology, p_rank, p___coordinates_len, p_coordinates);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_CartDimension`) */
void barectf_default_trace_GlobalDef_CartDimension(struct barectf_default_ctx * const sctx,
	const uint32_t p_self,
	const uint32_t p_name,
	const uint32_t p_size,
	const uint8_t p_cartPeriodicity)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_CartDimension(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_CartDimension(_TO_VOID_PTR(ctx), p_self, p_name, p_size, p_cartPeriodicity);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_CartTopology`) */
void barectf_default_trace_GlobalDef_CartTopology(struct barectf_default_ctx * const sctx,
	const uint32_t p_self,
	const uint32_t p_name,
	const uint32_t p_communicator,
	const uint32_t p___cartDimensions_len,
	const uint32_t * const p_cartDimensions)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_CartTopology(_TO_VOID_PTR(ctx), p___cartDimensions_len, p_cartDimensions);

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_CartTopology(_TO_VOID_PTR(ctx), p_self, p_name, p_communicator, p___cartDimensions_len, p_cartDimensions);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_ClockProperties`) */
void barectf_default_trace_GlobalDef_ClockProperties(struct barectf_default_ctx * const sctx,
	const uint64_t p_timerResolution,
	const uint64_t p_globalOffset,
	const uint64_t p_traceLength)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_ClockProperties(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_ClockProperties(_TO_VOID_PTR(ctx), p_timerResolution, p_globalOffset, p_traceLength);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_Comm`) */
void barectf_default_trace_GlobalDef_Comm(struct barectf_default_ctx * const sctx,
	const uint32_t p_self,
	const uint32_t p_name,
	const uint32_t p_group,
	const uint32_t p_parent)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_Comm(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_Comm(_TO_VOID_PTR(ctx), p_self, p_name, p_group, p_parent);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_Group`) */
void barectf_default_trace_GlobalDef_Group(struct barectf_default_ctx * const sctx,
	const uint32_t p_self,
	const uint32_t p_name,
	const uint8_t p_groupType,
	const uint8_t p_paradigm,
	const uint32_t p_groupFlags,
	const uint32_t p_numberOfMembers)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_Group(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_Group(_TO_VOID_PTR(ctx), p_self, p_name, p_groupType, p_paradigm, p_groupFlags, p_numberOfMembers);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_GroupMember`) */
void barectf_default_trace_GlobalDef_GroupMember(struct barectf_default_ctx * const sctx,
	const uint32_t p_group,
	const uint32_t p_rank,
	const uint64_t p_location)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_GroupMember(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_GroupMember(_TO_VOID_PTR(ctx), p_group, p_rank, p_location);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_InterruptGenerator`) */
void barectf_default_trace_GlobalDef_InterruptGenerator(struct barectf_default_ctx * const sctx,
	const uint32_t p_self,
	const uint32_t p_name,
	const uint8_t p_interruptGeneratorMode,
	const uint8_t p_base,
	const int64_t p_exponent,
	const uint64_t p_period)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_InterruptGenerator(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_InterruptGenerator(_TO_VOID_PTR(ctx), p_self, p_name, p_interruptGeneratorMode, p_base, p_exponent, p_period);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_IoDirectory`) */
void barectf_default_trace_GlobalDef_IoDirectory(struct barectf_default_ctx * const sctx,
	const uint32_t p_self,
	const uint32_t p_name,
	const uint32_t p_scope)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_IoDirectory(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_IoDirectory(_TO_VOID_PTR(ctx), p_self, p_name, p_scope);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_IoFileProperty`) */
void barectf_default_trace_GlobalDef_IoFileProperty(struct barectf_default_ctx * const sctx,
	const uint32_t p_ioFile,
	const uint32_t p_name)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_IoFileProperty(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_IoFileProperty(_TO_VOID_PTR(ctx), p_ioFile, p_name);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_IoHandle`) */
void barectf_default_trace_GlobalDef_IoHandle(struct barectf_default_ctx * const sctx,
	const uint32_t p_self,
	const uint32_t p_name,
	const uint32_t p_file,
	const uint8_t p_ioParadigm,
	const uint32_t p_ioHandleFlags,
	const uint32_t p_comm,
	const uint32_t p_parent)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_IoHandle(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_IoHandle(_TO_VOID_PTR(ctx), p_self, p_name, p_file, p_ioParadigm, p_ioHandleFlags, p_comm, p_parent);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_IoParadigm`) */
void barectf_default_trace_GlobalDef_IoParadigm(struct barectf_default_ctx * const sctx,
	const uint8_t p_self,
	const uint32_t p_identification,
	const uint32_t p_name,
	const uint8_t p_ioParadigmClass,
	const uint32_t p_ioParadigmFlags,
	const uint8_t p_numberOfProperties)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_IoParadigm(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_IoParadigm(_TO_VOID_PTR(ctx), p_self, p_identification, p_name, p_ioParadigmClass, p_ioParadigmFlags, p_numberOfProperties);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_IoParadigmProperty`) */
void barectf_default_trace_GlobalDef_IoParadigmProperty(struct barectf_default_ctx * const sctx,
	const uint8_t p_ioParadigm,
	const uint8_t p_ioParadigmProperty)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_IoParadigmProperty(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_IoParadigmProperty(_TO_VOID_PTR(ctx), p_ioParadigm, p_ioParadigmProperty);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_IoPreCreatedHandleState`) */
void barectf_default_trace_GlobalDef_IoPreCreatedHandleState(struct barectf_default_ctx * const sctx,
	const uint32_t p_ioHandle,
	const uint8_t p_mode,
	const uint32_t p_statusFlags)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_IoPreCreatedHandleState(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_IoPreCreatedHandleState(_TO_VOID_PTR(ctx), p_ioHandle, p_mode, p_statusFlags);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_IoRegularFile`) */
void barectf_default_trace_GlobalDef_IoRegularFile(struct barectf_default_ctx * const sctx,
	const uint32_t p_self,
	const uint32_t p_name,
	const uint32_t p_scope)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_IoRegularFile(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_IoRegularFile(_TO_VOID_PTR(ctx), p_self, p_name, p_scope);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_Location`) */
void barectf_default_trace_GlobalDef_Location(struct barectf_default_ctx * const sctx,
	const uint64_t p_self,
	const uint32_t p_name,
	const uint8_t p_locationType,
	const uint64_t p_numberOfEvents,
	const uint32_t p_locationGroup)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_Location(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_Location(_TO_VOID_PTR(ctx), p_self, p_name, p_locationType, p_numberOfEvents, p_locationGroup);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_LocationGroup`) */
void barectf_default_trace_GlobalDef_LocationGroup(struct barectf_default_ctx * const sctx,
	const uint32_t p_self,
	const uint32_t p_name,
	const uint8_t p_locationGroupType,
	const uint32_t p_systemTreeParent)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_LocationGroup(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_LocationGroup(_TO_VOID_PTR(ctx), p_self, p_name, p_locationGroupType, p_systemTreeParent);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_LocationGroupProperty`) */
void barectf_default_trace_GlobalDef_LocationGroupProperty(struct barectf_default_ctx * const sctx,
	const uint32_t p_locationGroup,
	const uint32_t p_name)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_LocationGroupProperty(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_LocationGroupProperty(_TO_VOID_PTR(ctx), p_locationGroup, p_name);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_LocationProperty`) */
void barectf_default_trace_GlobalDef_LocationProperty(struct barectf_default_ctx * const sctx,
	const uint64_t p_location,
	const uint32_t p_name)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_LocationProperty(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_LocationProperty(_TO_VOID_PTR(ctx), p_location, p_name);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_MetricClass`) */
void barectf_default_trace_GlobalDef_MetricClass(struct barectf_default_ctx * const sctx,
	const uint32_t p_self,
	const uint32_t p___metricMembers_len,
	const uint32_t * const p_metricMembers,
	const uint8_t p_metricOccurrence,
	const uint8_t p_recorderKind)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_MetricClass(_TO_VOID_PTR(ctx), p___metricMembers_len, p_metricMembers);

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_MetricClass(_TO_VOID_PTR(ctx), p_self, p___metricMembers_len, p_metricMembers, p_metricOccurrence, p_recorderKind);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_MetricClassRecorder`) */
void barectf_default_trace_GlobalDef_MetricClassRecorder(struct barectf_default_ctx * const sctx,
	const uint32_t p_metric,
	const uint64_t p_recorder)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_MetricClassRecorder(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_MetricClassRecorder(_TO_VOID_PTR(ctx), p_metric, p_recorder);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_MetricInstance`) */
void barectf_default_trace_GlobalDef_MetricInstance(struct barectf_default_ctx * const sctx,
	const uint32_t p_self,
	const uint32_t p_metricClass,
	const uint64_t p_recorder,
	const uint8_t p_metricScope,
	const uint64_t p_scope)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_MetricInstance(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_MetricInstance(_TO_VOID_PTR(ctx), p_self, p_metricClass, p_recorder, p_metricScope, p_scope);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_MetricMember`) */
void barectf_default_trace_GlobalDef_MetricMember(struct barectf_default_ctx * const sctx,
	const uint32_t p_self,
	const uint32_t p_name,
	const uint32_t p_description,
	const uint8_t p_metricType,
	const uint8_t p_metricMode,
	const uint8_t p_valueType,
	const uint8_t p_base,
	const int64_t p_exponent,
	const uint32_t p_unit)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_MetricMember(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_MetricMember(_TO_VOID_PTR(ctx), p_self, p_name, p_description, p_metricType, p_metricMode, p_valueType, p_base, p_exponent, p_unit);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_Paradigm`) */
void barectf_default_trace_GlobalDef_Paradigm(struct barectf_default_ctx * const sctx,
	const uint8_t p_paradigm,
	const uint32_t p_name,
	const uint8_t p_paradigmClass)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_Paradigm(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_Paradigm(_TO_VOID_PTR(ctx), p_paradigm, p_name, p_paradigmClass);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_ParadigmProperty`) */
void barectf_default_trace_GlobalDef_ParadigmProperty(struct barectf_default_ctx * const sctx,
	const uint8_t p_paradigm,
	const uint8_t p_property)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_ParadigmProperty(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_ParadigmProperty(_TO_VOID_PTR(ctx), p_paradigm, p_property);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_Parameter`) */
void barectf_default_trace_GlobalDef_Parameter(struct barectf_default_ctx * const sctx,
	const uint32_t p_self,
	const uint32_t p_name,
	const uint8_t p_parameterType)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_Parameter(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_Parameter(_TO_VOID_PTR(ctx), p_self, p_name, p_parameterType);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_Region`) */
void barectf_default_trace_GlobalDef_Region(struct barectf_default_ctx * const sctx,
	const uint32_t p_self,
	const uint32_t p_name,
	const uint32_t p_canonicalName,
	const uint32_t p_description,
	const uint8_t p_regionRole,
	const uint8_t p_paradigm,
	const uint32_t p_regionFlag,
	const uint32_t p_sourceFile,
	const uint32_t p_beginLineNumber,
	const uint32_t p_endLineNumber)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_Region(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_Region(_TO_VOID_PTR(ctx), p_self, p_name, p_canonicalName, p_description, p_regionRole, p_paradigm, p_regionFlag, p_sourceFile, p_beginLineNumber, p_endLineNumber);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_RmaWin`) */
void barectf_default_trace_GlobalDef_RmaWin(struct barectf_default_ctx * const sctx,
	const uint32_t p_self,
	const uint32_t p_name,
	const uint32_t p_comm)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_RmaWin(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_RmaWin(_TO_VOID_PTR(ctx), p_self, p_name, p_comm);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_SourceCodeLocation`) */
void barectf_default_trace_GlobalDef_SourceCodeLocation(struct barectf_default_ctx * const sctx,
	const uint32_t p_self,
	const uint32_t p_file,
	const uint32_t p_lineNumber)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_SourceCodeLocation(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_SourceCodeLocation(_TO_VOID_PTR(ctx), p_self, p_file, p_lineNumber);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_String`) */
void barectf_default_trace_GlobalDef_String(struct barectf_default_ctx * const sctx,
	const uint32_t p_self,
	const char * const p_stringValue)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_String(_TO_VOID_PTR(ctx), p_stringValue);

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_String(_TO_VOID_PTR(ctx), p_self, p_stringValue);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_SystemTreeNode`) */
void barectf_default_trace_GlobalDef_SystemTreeNode(struct barectf_default_ctx * const sctx,
	const uint32_t p_self,
	const uint32_t p_name,
	const uint32_t p_className,
	const uint32_t p_systemTreeParent)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_SystemTreeNode(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_SystemTreeNode(_TO_VOID_PTR(ctx), p_self, p_name, p_className, p_systemTreeParent);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_SystemTreeNodeDomain`) */
void barectf_default_trace_GlobalDef_SystemTreeNodeDomain(struct barectf_default_ctx * const sctx,
	const uint32_t p_systemTreeNode,
	const uint8_t p_systemTreeDomain)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_SystemTreeNodeDomain(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_SystemTreeNodeDomain(_TO_VOID_PTR(ctx), p_systemTreeNode, p_systemTreeDomain);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `GlobalDef_SystemTreeNodeProperty`) */
void barectf_default_trace_GlobalDef_SystemTreeNodeProperty(struct barectf_default_ctx * const sctx,
	const uint32_t p_systemTreeNode,
	const uint32_t p_name)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_GlobalDef_SystemTreeNodeProperty(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_GlobalDef_SystemTreeNodeProperty(_TO_VOID_PTR(ctx), p_systemTreeNode, p_name);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `MetricValue_Double`) */
void barectf_default_trace_MetricValue_Double(struct barectf_default_ctx * const sctx,
	const double p_metricValue)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_MetricValue_Double(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_MetricValue_Double(_TO_VOID_PTR(ctx), p_metricValue);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `MetricValue_Int64`) */
void barectf_default_trace_MetricValue_Int64(struct barectf_default_ctx * const sctx,
	const int64_t p_metricValue)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_MetricValue_Int64(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_MetricValue_Int64(_TO_VOID_PTR(ctx), p_metricValue);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `MetricValue_UInt64`) */
void barectf_default_trace_MetricValue_UInt64(struct barectf_default_ctx * const sctx,
	const uint64_t p_metricValue)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_MetricValue_UInt64(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_MetricValue_UInt64(_TO_VOID_PTR(ctx), p_metricValue);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}
